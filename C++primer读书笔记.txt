==========================================================================================================
第10章：泛型算法(绝多数的算法支持迭代器)
--------------------
10.3、定制操作
1、why(为什么要有定制操作)
# sort的排序算法默认使用元素类型的<运算符,但是可能需要其他的比较方式,因此需要重载sort

2、HOW(实现)
# 重载的sort函数接受第三个参数,引入"谓词"
	$ 谓词：
		>> 可调用的表达式,返回结果是一个能作为条件的值
		>> 分类：一个参数称为一元谓词,两个参数称为二元谓词	

# sort算法：接受一个迭代器范围,按照递增的顺序排列元素
		
# stable_sort算法：接受一个迭代器范围和谓词,维持相等元素的原有顺序

# find_if算法：接受一个迭代器范围和一元谓词,返回第一个使一元谓词返回非0的元素,不存在则返回尾迭代器

# for_each算法：接受一个迭代器范围和调用对象(lambda),对其输入序列调用此对象

# unique算法：使得每个单词只出现一遍,返回指向不重复区域之后一个位置的迭代器

# copy算法：形如copy(begin(a), end(a), b),将a的内容拷贝到b中

# find算法：形如find(c.begin, c.end, ','),在容器c中查找第一个字符','的元素，返回指向该元素的迭代器

# lambda表达式：
	$ 作用：表示一个可调用的代码单元(函数和函数指针就属于可调用对象),可以理解为一个无名字的内联函数
	
	$ 格式：[捕获列表] (参数列表) -> return type { 函数体 }
	
	$ 调用：与普通函数一致
	
	$ 注意：lambda不支持默认参数、lambda在函数体中可以直接使用定义在当前函数外的名字
	
	$ 参数：捕获列表用于指引lambda在内部包含访问局部变量所需的信息,多个可以用逗号分隔
	        只有在捕获列表中指定了才能在函数体中使用该变量
			
	$ 捕获：lambda在定义时就初始化了所捕获的变量,而不是在调用是进行初始化杀
		>> 值捕获：变量可拷贝,在定义时就发生了拷贝
		>> 引用捕获：使用引用的变量时实际上就是使用引用所绑定的变量,使用方式 [&a] {....;};
		
	$ 隐式捕获：由编译器根据lambda中的代码来推断我们要使用哪些变量，使用方式 [&/=] {....;};
		>> 其中捕获列表中的&表示引用捕获,=表示值捕获,
		>> 当隐式捕获和显式捕获混合使用时,捕获列表中的第一个元素必须是&/=,且显式捕获要与隐式捕获采用不同的方式
		
	$ 可变lambda：
		>> 对于值捕获,如果想要修改被捕获变量的值,应该加入关键字mutable,形如：[a] () mutable {++a;};
		>> 对于引用捕获,能否修改捕获变量的值取决于局部变量是否是const,只用非const才能修改
	
	$ 指定lambda返回类型
		>> 如果lambda函数体中有除了return以外的语句,则被编译器默认为返回值为void,即不返回
		>> 针对上述情况,需要指定返回类型,形如：[] (int i) -> int { if(i) return -i; };
		
# 标准库函数bind
	$ 作用：一个通用的函数适配器,用于解决某些时候某些函数的限制
	
	$ 使用格式形如：auto check6 = bind(check_size, _1, 6);
	  表示check6接受一个与check_size第一个参数一致的参数,当调用check6时传递的参数会传递到check_size
	  
	$ 在使用_1或形如_n的时候要包含命令空间：using namespace std::placeholders
	
	$ 在使用bind生成新的调用函数后
		>> 形如：auto g = bind(f, a, b, c, _2, d, _1);
	    >> 当调用g(X, Y)时即调用：f(a, b, c, Y, d, X);这样的使用方法称为：用bind重排参数顺序
	  
	$ 由于bind是拷贝参数的方式,但某些参数无法拷贝时,如ostream os,此时需要使用标准库ref函数返回给定的应用
	  而cref返回一个const的引用
		>> 形如：bind(print, ref(os), -1, '')
	  
--------------------	 
10.4、再探迭代器
1、迭代器类型
# 插入迭代器
	$ what：插入器是一种迭代适配器,接受一个容器,生成一个迭代器用于向给定的容器添加元素
	
	$ HOW：当向一个插入迭代器赋值时,即将该元素插入到当前位置上
	
	$ 类型：
		>> back_insert创建一个使用push_back的迭代器,插入的元素调用c.push_back
		>> front_inser创建一个使用push_front的迭代器,插入的元素调用c.push_front
		>> insert创建一个insert的迭代器：接受第二个指向该容器的迭代器,表示将元素插入到该迭代器之前
	
	$ why(原理)：对于语句：
		auto it = insert(c, c.cbengin())：
		*it = val;
		类似于：
		auto it = c.insert(c.cbegin(),val);
		++it；
		
# iostream迭代器
	$ istream_iterator
		>> 使用>>来读取流,绑定的对象必须支持输入运算符
		>> 形如 istream_iterator<int> in(cin);表示从标准输入中读取int
		>> istream_iterator<int> eof 表示一个初始化为空,表示一个尾后迭代器
		>> istream_iterator绑定到一个流时，标准库并不保证迭代器立即从流读取数据
	  
	$ ostream_iterator
		>> ostream_iterator<int> out(os); out将int类型的值写到输出流os
		>> ostream_iterator<int> out(os, d); out将int类型的值写到输出流os,并在值后跟d,d为指向一个空字符结尾的字符串
	  
# 反向迭代器
	$ what：反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器
		>> forward_list不支持反向迭代器
		>> 调用rbegin、rend，或crbegin、crend成员函数获取反向迭代器
		
	$ HOW
		>> 当反向迭代器时想要转化成正向迭代器,则调用迭代器成员函数base,函数返回的迭代器与反向迭代器相邻
		
		
--------------------	 
10.5、泛型算法结构
	>> 根据算法的实现要求迭代器支持的操作类型不一致,因此引入了5类迭代器
1、5类迭代器
	>> 高层类别的迭代器支持低层类别迭代器的所有操作
	
	$ 输入迭代器
		>> 只读不写,单遍扫描,只能递增
		>> find、accumulate要求输入迭代器,而istream_iterator是一种输入迭代器
		>> 解引用出现在赋值运算符的右侧
	
	$ 输出迭代器
		>> 只写不读,单遍扫描,只能递增
		>> 解引用在出现在赋值运算符的左侧
	
	$ 前向迭代器
		>> 读写元素,只能在序列中沿一个方向移动
		
	$ 双向迭代器
	    >> 可以正向反向读写序列中的元素
		
	$ 随机访问迭代器
		>> 可以再常数时间内访问序列中的任意元素

2、算法形参模式
	>> 算法一般都包含有一个迭代器表示的输入范围
	>> 算法还可以接受一个假定目的位置的迭代器所绑定的容器足够容纳写入的元素
	>> 算法同样也可以接受第二个迭代器表示的范围

3、算法命名规范
	>> 接受谓词参数或者一般不接受额外参数的算法都是重载后的算法
	>> 形参个数相同,但是函数的命名不同,此类函数非重载版本(_if版本)
	>> 区分拷贝元素和不拷贝元素的版本(一般附加一个_copy)
		
--------------------	 
10.6、特定容器算法
	>> list(双向迭代器)、forward_list(前向迭代器)单独提供了一套特定的算法：
	   sort、erase、remove、merge、reverse、unique
	  
	>> splice算法没有通用,都是定制算法,用于移动另一链表元素到链表中
	
	>> 链表实现的特定版本算法会改变容器,而通用算法一般不会

==========================================================================================================	
第11章：关联容器
	>> what：1.与顺序容器为同一级,但是从根本上不相同,保存和访问容器中的元素是按照关键字来进行
			 2.支持高效的关键字查找和访问,map和set类型是最重要的两个关联容器
			 
	>> map：元素为key-value对;
	
	>> set：每个元素只包含一个关键字
	
	>> 关键字重复的关联容器包含multi,无序的关联容器以unordered开头
	
	>> 无序的容器使用哈希函数来组织元素
	
--------------------
11.1、使用关联容器
	$ 
	
	







	

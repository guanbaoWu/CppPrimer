第10章：泛型算法
10.3、定制操作
1、why(为什么要有定制操作)
# sort的排序算法默认使用元素类型的<运算符,但是可能需要其他的比较方式,因此需要重载sort

2、HOW(实现)
# 重载的sort函数接受第三个参数,引入"谓词"
	$ 谓词：
		>> 可调用的表达式,返回结果是一个能作为条件的值
		>> 分类：一个参数称为一元谓词,两个参数称为二元谓词	
		
# stable_sort算法：接受一个迭代器范围和谓词,维持相等元素的原有顺序

# find_if算法：接受一个迭代器范围和一元谓词,返回第一个使一元谓词返回非0的元素,不存在则返回尾迭代器

# for_each算法：接受一个迭代器范围和调用对象(lambda),对其输入序列调用此对象

# lambda表达式：
	$ 作用：表示一个可调用的代码单元(函数和函数指针就属于可调用对象),可以理解为一个无名字的内联函数
	
	$ 格式：[捕获列表] (参数列表) -> return type { 函数体 }
	
	$ 调用：与普通函数一致
	
	$ 注意：lambda不支持默认参数、lambda在函数体中可以直接使用定义在当前函数外的名字
	
	$ 参数：捕获列表用于指引lambda在内部包含访问局部变量所需的信息,多个可以用逗号分隔
	        只有在捕获列表中指定了才能在函数体中使用该变量
			
	$ 捕获：lambda在定义时就初始化了所捕获的变量,而不是在调用是进行初始化杀
		>> 值捕获：变量可拷贝,在定义时就发生了拷贝
		>> 引用捕获：使用引用的变量时实际上就是使用引用所绑定的变量,使用方式 [&a] {....;};
		
	$ 隐式捕获：由编译器根据lambda中的代码来推断我们要使用哪些变量，使用方式 [&/=] {....;};
		>> 其中捕获列表中的&表示引用捕获,=表示值捕获,
		>> 当隐式捕获和显式捕获混合使用时,捕获列表中的第一个元素必须是&/=,且显式捕获要与隐式捕获采用不同的方式
		
	$ 可变lambda：
		>> 对于值捕获,如果想要修改被捕获变量的值,应该加入关键字mutable,形如：[a] () mutable {++i;};
		>> 对于引用捕获,能否修改捕获变量的值取决于局部变量是否是const,只用非const才能修改
	
	$ 指定lambda返回类型
		>> 如果lambda函数体中有除了return以外的语句,则被编译器默认为返回值为void,即不返回
		>> 针对上述情况,需要指定返回类型,形如：[] (int i) -> int { if(i) return -i; };
		
		
		
		
		
		
		
		
		


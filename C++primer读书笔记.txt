==========================================================================================================
第一章~第九章：
>> decltype用于函数指针的别名创建,形如：typedef decltype(func) *FuncP 定义FuncP为指向func函数类型的函数指针
>> initializer_list<T> lst;用于函数的实参数量未知但是全部实参的类型相同
	% void error_msg(initializer_list<string> l){}
	% 可使用begin,end等通用操作
>> explicit用于限制构造函数执行隐式转换,只能采用直接初始化的方式(圆括号初始化)
	
==========================================================================================================
第10章：泛型算法(绝多数的算法支持迭代器)
--------------------
10.3、定制操作
1、why(为什么要有定制操作)
# sort的排序算法默认使用元素类型的<运算符,但是可能需要其他的比较方式,因此需要重载sort

2、HOW(实现)
# 重载的sort函数接受第三个参数,引入"谓词"
	$ 谓词：
		>> 可调用的表达式,返回结果是一个能作为条件的值
		>> 分类：一个参数称为一元谓词,两个参数称为二元谓词	

# sort算法：接受一个迭代器范围,按照递增的顺序排列元素
		
# stable_sort算法：接受一个迭代器范围和谓词,维持相等元素的原有顺序

# find_if算法：接受一个迭代器范围和一元谓词,返回第一个使一元谓词返回非0的元素,不存在则返回尾迭代器

# for_each算法：接受一个迭代器范围和调用对象(lambda),对其输入序列调用此对象

# unique算法：使得每个单词只出现一遍,返回指向不重复区域之后一个位置的迭代器

# copy算法：形如copy(begin(a), end(a), b),将a的内容拷贝到b中

# find算法：形如find(c.begin, c.end, ','),在容器c中查找第一个字符','的元素，返回指向该元素的迭代器

# lambda表达式：
	$ 作用：表示一个可调用的代码单元(函数和函数指针就属于可调用对象),可以理解为一个无名字的内联函数
	
	$ 格式：[捕获列表] (参数列表) -> return type { 函数体 }
	
	$ 调用：与普通函数一致
	
	$ 注意：lambda不支持默认参数、lambda在函数体中可以直接使用定义在当前函数外的名字
	
	$ 参数：捕获列表用于指引lambda在内部包含访问局部变量所需的信息,多个可以用逗号分隔
	        只有在捕获列表中指定了才能在函数体中使用该变量
			
	$ 捕获：lambda在定义时就初始化了所捕获的变量,而不是在调用是进行初始化杀
		>> 值捕获：变量可拷贝,在定义时就发生了拷贝
		>> 引用捕获：使用引用的变量时实际上就是使用引用所绑定的变量,使用方式 [&a] {....;};
		
	$ 隐式捕获：由编译器根据lambda中的代码来推断我们要使用哪些变量，使用方式 [&/=] {....;};
		>> 其中捕获列表中的&表示引用捕获,=表示值捕获,
		>> 当隐式捕获和显式捕获混合使用时,捕获列表中的第一个元素必须是&/=,且显式捕获要与隐式捕获采用不同的方式
		
	$ 可变lambda：
		>> 对于值捕获,如果想要修改被捕获变量的值,应该加入关键字mutable,形如：[a] () mutable {++a;};
		>> 对于引用捕获,能否修改捕获变量的值取决于局部变量是否是const,只用非const才能修改
	
	$ 指定lambda返回类型
		>> 如果lambda函数体中有除了return以外的语句,则被编译器默认为返回值为void,即不返回
		>> 针对上述情况,需要指定返回类型,形如：[] (int i) -> int { if(i) return -i; };
		
# 标准库函数bind
	$ 作用：一个通用的函数适配器,用于解决某些时候某些函数的限制
	
	$ 使用格式形如：auto check6 = bind(check_size, _1, 6);
	  表示check6接受一个与check_size第一个参数一致的参数,当调用check6时传递的参数会传递到check_size
	  
	$ 在使用_1或形如_n的时候要包含命令空间：using namespace std::placeholders
	
	$ 在使用bind生成新的调用函数后
		>> 形如：auto g = bind(f, a, b, c, _2, d, _1);
	    >> 当调用g(X, Y)时即调用：f(a, b, c, Y, d, X);这样的使用方法称为：用bind重排参数顺序
	  
	$ 由于bind是拷贝参数的方式,但某些参数无法拷贝时,如ostream os,此时需要使用标准库ref函数返回给定的应用
	  而cref返回一个const的引用
		>> 形如：bind(print, ref(os), -1, '')
	  
--------------------	 
10.4、再探迭代器
1、迭代器类型
# 插入迭代器
	$ what：插入器是一种迭代适配器,接受一个容器,生成一个迭代器用于向给定的容器添加元素
	
	$ HOW：当向一个插入迭代器赋值时,即将该元素插入到当前位置上
	
	$ 类型：
		>> back_inserter创建一个使用push_back的迭代器,插入的元素调用c.push_back
		>> front_inserer创建一个使用push_front的迭代器,插入的元素调用c.push_front
		>> inserter创建一个insert的迭代器：接受第二个指向该容器的迭代器,表示将元素插入到该迭代器之前
	
	$ why(原理)：对于语句：
		auto it = insert(c, c.cbengin())：
		*it = val;
		类似于：
		auto it = c.insert(c.cbegin(),val);
		++it；
		
# iostream迭代器
	$ istream_iterator
		>> 使用>>来读取流,绑定的对象必须支持输入运算符
		>> 形如 istream_iterator<int> in(cin);表示从标准输入中读取int
		>> istream_iterator<int> eof 表示一个初始化为空,表示一个尾后迭代器
		>> istream_iterator绑定到一个流时，标准库并不保证迭代器立即从流读取数据
	  
	$ ostream_iterator
		>> ostream_iterator<int> out(os); out将int类型的值写到输出流os
		>> ostream_iterator<int> out(os, d); out将int类型的值写到输出流os,并在值后跟d,d为指向一个空字符结尾的字符串
	  
# 反向迭代器
	$ what：反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器
		>> forward_list不支持反向迭代器
		>> 调用rbegin、rend，或crbegin、crend成员函数获取反向迭代器
		
	$ HOW
		>> 当反向迭代器时想要转化成正向迭代器,则调用迭代器成员函数base,函数返回的迭代器与反向迭代器相邻
		
		
--------------------	 
10.5、泛型算法结构
	>> 根据算法的实现要求迭代器支持的操作类型不一致,因此引入了5类迭代器
1、5类迭代器
	>> 高层类别的迭代器支持低层类别迭代器的所有操作
	
	$ 输入迭代器
		>> 只读不写,单遍扫描,只能递增
		>> find、accumulate要求输入迭代器,而istream_iterator是一种输入迭代器
		>> 解引用出现在赋值运算符的右侧
	
	$ 输出迭代器
		>> 只写不读,单遍扫描,只能递增
		>> 解引用在出现在赋值运算符的左侧
	
	$ 前向迭代器
		>> 读写元素,只能在序列中沿一个方向移动
		
	$ 双向迭代器
	    >> 可以正向反向读写序列中的元素
		
	$ 随机访问迭代器
		>> 可以再常数时间内访问序列中的任意元素

2、算法形参模式
	>> 算法一般都包含有一个迭代器表示的输入范围
	>> 算法还可以接受一个假定目的位置的迭代器所绑定的容器足够容纳写入的元素
	>> 算法同样也可以接受第二个迭代器表示的范围

3、算法命名规范
	>> 接受谓词参数或者一般不接受额外参数的算法都是重载后的算法
	>> 形参个数相同,但是函数的命名不同,此类函数非重载版本(_if版本)
	>> 区分拷贝元素和不拷贝元素的版本(一般附加一个_copy)
		
--------------------	 
10.6、特定容器算法
	>> list(双向迭代器)、forward_list(前向迭代器)单独提供了一套特定的算法：
	   sort、erase、remove、merge、reverse、unique
	  
	>> splice算法没有通用,都是定制算法,用于移动另一链表元素到链表中
	
	>> 链表实现的特定版本算法会改变容器,而通用算法一般不会

==========================================================================================================	
第11章：关联容器
	>> what：1.与顺序容器为同一级,但是从根本上不相同,保存和访问容器中的元素是按照关键字来进行
			 2.支持高效的关键字查找和访问,map和set类型是最重要的两个关联容器
			 
	>> map：元素为key-value对;
	
	>> set：每个元素只包含一个关键字
	
	>> 关键字重复的关联容器包含multi,无序的关联容器以unordered开头
	
	>> 无序的容器使用哈希函数来组织元素
	
--------------------
11.1、使用关联容器
	$ map
		>> 创建：map<string, size_t> word_count;
		>> map中的元素为pair类型的对象,可以使用first表示关键字,second表示值
		
	$ set
		>> 创建：set<string> exclude = {"hi", "hello"}
		>> 判断是否在set中,调用：exclude.find(string word),找到返回对应元素的迭代器,否则返回尾后迭代器
	
--------------------
11.2、关联容器概述
	>> 关联容器不支持顺序容器的位置相关的操作,如push_front,push_back操作
	>> 关联容器的迭代器为双向迭代器
	
	$ 定义关联容器
		>> 形如：multimap<int> mimap(v.cbegin(), v.cend());定义关键字重复的set
	
	$ 关键字类型的要求
		>> 对于有序的关联容器,关键字类型必须定义元素比较的方法,默认情况使用"<"运算符比较
		>> 当自定义操作来代替关键字的默认比较运算符时,所提供的操作必须在关键字类型上定义一个严格弱序
		>> 严格弱序：可看做小于等于
		>> 关键字等价：存在两个关键字都不小于等于另一个,则这两个关键字称为等价,关联同一个元素
		>> 形如：multiset<Sales_data, decltype(func)*> bookstore表示用函数func进行元素的有序排列
	
	$ pair类型
		>> 标准库类型,定义在utility.h,保存两个类型不要求一样的数据成员,是用来生成特定类型的模板
		>> pair的数据成员是public,可以使用first、second进行访问
		>> p1 relop p2 按关系运算符进行比较,当p1 < p2 时为true
	    >> pair的初始化支持默认值初始化、列表初始化、make_pair的初始化

--------------------
11.3、关联容器操作
	$ 关联容器定义了三种额外的类型
		>> key_type：关键字类型
		>> mapped_type：关键字关联的类型(值)---只有map有该类型
		>> value_type：对于set,与key_type相同,对于map,为pair<const key_type, mapped_type>(容器元素)
	
	$ 关联容器迭代器
		>> 关联容器迭代器解引用获得是value_type类型
		>> set的元素都是const类型的,只读不能改变
		>> map、set都支持begin()和end()操作获取迭代器iterator
		>> 有序的关联迭代器排列是按照字典序排列,遍历按照升序遍历
		>> 关联容器一般不适用泛型算法,因为：1、关联容器中的关键字为const 2、关键字一般无法快速查找容器元素
		
	$ 添加元素
		>> 关联容器支持成员函数insert用于向元素插入一个元素或一个元素范围
		>> insert支持花括号列表插入和迭代器范围插入
		>> 对于map,插入的元素必须是pair类型
		>> 对于不重复元素的关联容器的插入：
			insert(v)返回的是一个pair类型,first成员为插入元素迭代器,second指示是否插入成功
			关键字存在容器中,则first为原值,second为false
	
	$ 删除元素
		>> erase支持三个版本：
		   % c.erase(p); //p为容器c中的真实存在的元素,返回void
		   % c.erase(b, e) //删除迭代b和e范围的元素,返回e
		   % c.erase(k)   //k为key_type类型,删除容器中k关联的元素,返回删除的元素个数
		
	$ map的下标操作
		>> set不支持下标操作
		>> map、unordered_map支持下标运算符和at函数
			% map的下标运算符为关键字,如果容器中不存在,则创建一个执行了值初始化的关联值组成的元素
			% c.at(k) //访问关键字为k的元素,如果不存在,则抛出异常
			% map的下标操作返回的是mapped_type的类型,是一个左值,可以读写
	
	$ 访问元素
		>> c.find返回一个指向第一个关键字为k的元素
		   % c.count返回一个关键k的对于的元素个数
		   % c.lowr_bound(k)返回第一个不小于关键字k的元素
		   % c.upper_bound(k)返回第一个大于关键字k的元素
		   % c.equal_range(k)返回一个迭代器pair,pair的两个成员表示等于k的元素范围迭代器
		>> 对于有序的multi容器,同一关键字的元素是相邻存储的

--------------------
11.4、无序容器
	>> 定义4个无序关联容器,使用哈希函数和关键字类型的==运算符来组织元素
	>> 无序容器通过桶保存,计算关键字的哈希值,获取对应的桶,从而得到元素

	
==========================================================================================================	
第12章：动态内存
--------------------
12.1、动态内存与智能指针
	$ 动态内存的管理是通过一对运算符来完成：
		>> new分配
		>> delete释放
		
	$ 智能指针--属于模板(类型vector)
		>> shared_ptr类：
			% 定义形如：shared_ptr<string> p1;
			% 智能指针shared_ptr存在引用计数,当计数为0时,则会释放管理的内存
			% make_shared<T>(arg),创建一个指向类型为T,初始值为arg的对象的shared_ptr类
			% 拷贝或者赋值时,每个shared_ptr都会记录有几个指向相同对象的shared_ptr
			% 当shared_ptr指向的对象的引用计数为0时,会调用shared_ptr的析构函数来销毁指向的对象
			% 当返回一个shred_ptr时,会拷贝一个shared_ptr,并递增指向对象的引用计数

	$ 直接管理内存
		>> new分配的对象是默认初始化的(注：非值初始化),内置类型其值是未定义的
		>> new可以使用直接初始化方式进行初始化,新的标准支持列表初始化(花括号)
			% 形如 vector<int> *vec1 = new vector<int>{1,,2,3,4,5};
		>> 也可以增加一个空括号执行值初始化
			% 形如：int *pi = new int();  //pi指向值为0的int对象
		>> new分配的const的对象必须进行初始化
		>> 当内存使用完后,使用new进行分配会抛出bad_alloc的异常
			% 定位new：允许向new传递额外的参数,形如：int *p2 = new(nothrow) int;

	$ shared_ptr和new结合使用
		>> shared_ptr默认的构造函数是explict的,即表明只能采用直接初始化而不能进行类型转换
			% 形如：share_ptr<int> pi(new int(42))才是合法的
		>> 智能指针默认使用delete释放所关联的对象
		>> 智能指针定义的get成员函数用于返回一个指向智能指针所关联对象的内置指针

	$ 智能指针和异常
		>> 智能指针可以自定义释放操作,形如
			% shared_ptr<type> p(q, func); // 创建一个q初始化指向type的对象的智能指针,释放时调用函数func进行释放
		>> reset不传递参数时,是销毁智能指针关联的对象,传递参数则是重新分配一个指向新对象的智能指针	
	
	$ unique_ptr
		>> what：某时刻只能有一个unique_ptr指向给定的对象
		>> how：定义一个unique_ptr需要将其绑定到一个new返回的指针上,且必须使用值初始化进行初始化
			% 不支持普通的拷贝和赋值
			% q.realease操作返回原来保存的指针后将其置空
			% q.reset(p);将q原指向的对象释放,并重新指向p指向的对象
		>> 当一个unique_ptr将要销毁时,可以执行拷贝或者赋值,常用于函数返回
	
	$ weak_ptr
		>> what：不控制所指向对象生存期的智能指针,它指向一个由share_ptr管理的对象,但不会增加引用计数
		>> how：
			% 不能直接使用weak_ptr访问对象,应当使用w.lock返回一个share_ptr的指针
			% w.lock：当w.expired()返回ture时返回空share_ptr,否则返回一个指向w对象的shred_ptr
			% w.expired()：当w.usecount()返回0为true
			% w.usecount()：返回与w共享的shred_ptr的对象个数
	
--------------------
12.2、动态数组
	$ new和数组
		>> 分配一个对象数组
			% 形如：int *pi = new int[get_size()]; //pi指向分配的第一个int
		>> 分配的得到是一个数组对象的元素类型指针,因此动态数组并不是数组类型,不能使用begin和end
		>> 分配的动态数组默认初始化,可以使用圆括号或者花括号列表进行值初始化
		>> new分配一个空的动态数组是合法的,但返回的指针类似于尾后迭代器,不可解引用
		>> 释放动态数组
			% 形如：delete [] p;表示释放的是一个p指向的动态数组
		>> unique_ptr可以管理new分配的动态数组
			% 形如：unique_ptr<int[]> u(new int[10]);
			% 当使用u.realease时会释放动态数组
		>> share_ptr不支持管理动态数组,并且未定义下标运算符,如果必须使用,则需要重载share_ptr的删除器
	
	
	
	
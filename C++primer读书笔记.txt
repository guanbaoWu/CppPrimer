==========================================================================================================
第一章~第九章：
>> decltype用于函数指针的别名创建,形如：typedef decltype(func) *FuncP 定义FuncP为指向func函数类型的函数指针
>> initializer_list<T> lst;用于函数的实参数量未知但是全部实参的类型相同
	% void error_msg(initializer_list<string> l){}
	% 可使用begin,end等通用操作
>> explicit用于限制构造函数执行隐式转换,只能采用直接初始化的方式(圆括号初始化)
>> 顶层const与底层const
	% 只有指针和引用才存在底层const
	% 顶层const表明指针变量是const,底层const表示指针所指对象为const
	% 默认存在的是顶层const,顶层const在转换时可以被忽略

==========================================================================================================
第10章：泛型算法(绝多数的算法支持迭代器)
--------------------
10.3、定制操作
1、why(为什么要有定制操作)
# sort的排序算法默认使用元素类型的<运算符,但是可能需要其他的比较方式,因此需要重载sort

2、HOW(实现)
# 重载的sort函数接受第三个参数,引入"谓词"
	$ 谓词：
		>> 可调用的表达式,返回结果是一个能作为条件的值
		>> 分类：一个参数称为一元谓词,两个参数称为二元谓词	

# sort算法：接受一个迭代器范围,按照递增的顺序排列元素
		
# stable_sort算法：接受一个迭代器范围和谓词,维持相等元素的原有顺序

# find_if算法：接受一个迭代器范围和一元谓词,返回第一个使一元谓词返回非0的元素,不存在则返回尾迭代器

# for_each算法：接受一个迭代器范围和调用对象(lambda),对其输入序列调用此对象

# unique算法：使得每个单词只出现一遍,返回指向不重复区域之后一个位置的迭代器

# copy算法：形如copy(begin(a), end(a), b),将a的内容拷贝到b中

# find算法：形如find(c.begin, c.end, ','),在容器c中查找第一个字符','的元素，返回指向该元素的迭代器

# lambda表达式：
	$ 作用：表示一个可调用的代码单元(函数和函数指针就属于可调用对象),可以理解为一个无名字的内联函数
	
	$ 格式：[捕获列表] (参数列表) -> return type { 函数体 }
	
	$ 调用：与普通函数一致
	
	$ 注意：lambda不支持默认参数、lambda在函数体中可以直接使用定义在当前函数外的名字
	
	$ 参数：捕获列表用于指引lambda在内部包含访问局部变量所需的信息,多个可以用逗号分隔
	        只有在捕获列表中指定了才能在函数体中使用该变量
			
	$ 捕获：lambda在定义时就初始化了所捕获的变量,而不是在调用是进行初始化杀
		>> 值捕获：变量可拷贝,在定义时就发生了拷贝
		>> 引用捕获：使用引用的变量时实际上就是使用引用所绑定的变量,使用方式 [&a] {....;};
		
	$ 隐式捕获：由编译器根据lambda中的代码来推断我们要使用哪些变量，使用方式 [&/=] {....;};
		>> 其中捕获列表中的&表示引用捕获,=表示值捕获,
		>> 当隐式捕获和显式捕获混合使用时,捕获列表中的第一个元素必须是&/=,且显式捕获要与隐式捕获采用不同的方式
		
	$ 可变lambda：
		>> 对于值捕获,如果想要修改被捕获变量的值,应该加入关键字mutable,形如：[a] () mutable {++a;};
		>> 对于引用捕获,能否修改捕获变量的值取决于局部变量是否是const,只用非const才能修改
	
	$ 指定lambda返回类型
		>> 如果lambda函数体中有除了return以外的语句,则被编译器默认为返回值为void,即不返回
		>> 针对上述情况,需要指定返回类型,形如：[] (int i) -> int { if(i) return -i; };
		
# 标准库函数bind
	$ 作用：一个通用的函数适配器,用于解决某些时候某些函数的限制
	
	$ 使用格式形如：auto check6 = bind(check_size, _1, 6);
	  表示check6接受一个与check_size第一个参数一致的参数,当调用check6时传递的参数会传递到check_size
	  
	$ 在使用_1或形如_n的时候要包含命令空间：using namespace std::placeholders
	
	$ 在使用bind生成新的调用函数后
		>> 形如：auto g = bind(f, a, b, c, _2, d, _1);
	    >> 当调用g(X, Y)时即调用：f(a, b, c, Y, d, X);这样的使用方法称为：用bind重排参数顺序
	  
	$ 由于bind是拷贝参数的方式,但某些参数无法拷贝时,如ostream os,此时需要使用标准库ref函数返回给定的引用
	  而cref返回一个const的引用
		>> 形如：bind(print, ref(os), -1, '')
	  
--------------------	 
10.4、再探迭代器
1、迭代器类型
# 插入迭代器
	$ what：插入器是一种迭代适配器,接受一个容器,生成一个迭代器用于向给定的容器添加元素
	
	$ HOW：当向一个插入迭代器赋值时,即将该元素插入到当前位置上
	
	$ 类型：
		>> back_inserter创建一个使用push_back的迭代器,插入的元素调用c.push_back
		>> front_inserer创建一个使用push_front的迭代器,插入的元素调用c.push_front
		>> inserter创建一个insert的迭代器：接受第二个指向该容器的迭代器,表示将元素插入到该迭代器之前
	
	$ why(原理)：对于语句：
		auto it = insert(c, c.cbengin())：
		*it = val;
		类似于：
		auto it = c.insert(c.cbegin(),val);
		++it；
		
# iostream迭代器
	$ istream_iterator
		>> 使用>>来读取流,绑定的对象必须支持输入运算符
		>> 形如 istream_iterator<int> in(cin);表示从标准输入中读取int
		>> istream_iterator<int> eof 表示一个初始化为空,表示一个尾后迭代器
		>> istream_iterator绑定到一个流时，标准库并不保证迭代器立即从流读取数据
	  
	$ ostream_iterator
		>> ostream_iterator<int> out(os); out将int类型的值写到输出流os
		>> ostream_iterator<int> out(os, d); out将int类型的值写到输出流os,并在值后跟d,d为指向一个空字符结尾的字符串
	  
# 反向迭代器
	$ what：反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器
		>> forward_list不支持反向迭代器
		>> 调用rbegin、rend，或crbegin、crend成员函数获取反向迭代器
		
	$ HOW
		>> 当反向迭代器时想要转化成正向迭代器,则调用迭代器成员函数base,函数返回的迭代器与反向迭代器相邻
		
		
--------------------	 
10.5、泛型算法结构
	>> 根据算法的实现要求迭代器支持的操作类型不一致,因此引入了5类迭代器
1、5类迭代器
	>> 高层类别的迭代器支持低层类别迭代器的所有操作
	
	$ 输入迭代器
		>> 只读不写,单遍扫描,只能递增
		>> find、accumulate要求输入迭代器,而istream_iterator是一种输入迭代器
		>> 解引用出现在赋值运算符的右侧
	
	$ 输出迭代器
		>> 只写不读,单遍扫描,只能递增
		>> 解引用在出现在赋值运算符的左侧
	
	$ 前向迭代器
		>> 读写元素,只能在序列中沿一个方向移动
		
	$ 双向迭代器
	    >> 可以正向反向读写序列中的元素
		
	$ 随机访问迭代器
		>> 可以再常数时间内访问序列中的任意元素

2、算法形参模式
	>> 算法一般都包含有一个迭代器表示的输入范围
	>> 算法还可以接受一个假定目的位置的迭代器所绑定的容器足够容纳写入的元素
	>> 算法同样也可以接受第二个迭代器表示的范围

3、算法命名规范
	>> 接受谓词参数或者一般不接受额外参数的算法都是重载后的算法
	>> 形参个数相同,但是函数的命名不同,此类函数非重载版本(_if版本)
	>> 区分拷贝元素和不拷贝元素的版本(一般附加一个_copy)
		
--------------------	 
10.6、特定容器算法
	>> list(双向迭代器)、forward_list(前向迭代器)单独提供了一套特定的算法：
	   sort、erase、remove、merge、reverse、unique
	  
	>> splice算法没有通用,都是定制算法,用于移动另一链表元素到链表中
	
	>> 链表实现的特定版本算法会改变容器,而通用算法一般不会

==========================================================================================================	
第11章：关联容器
	>> what：1.与顺序容器为同一级,但是从根本上不相同,保存和访问容器中的元素是按照关键字来进行
			 2.支持高效的关键字查找和访问,map和set类型是最重要的两个关联容器
			 
	>> map：元素为key-value对;
	
	>> set：每个元素只包含一个关键字
	
	>> 关键字重复的关联容器包含multi,无序的关联容器以unordered开头
	
	>> 无序的容器使用哈希函数来组织元素
	
--------------------
11.1、使用关联容器
	$ map
		>> 创建：map<string, size_t> word_count;
		>> map中的元素为pair类型的对象,可以使用first表示关键字,second表示值
		
	$ set
		>> 创建：set<string> exclude = {"hi", "hello"}
		>> 判断是否在set中,调用：exclude.find(string word),找到返回对应元素的迭代器,否则返回尾后迭代器
	
--------------------
11.2、关联容器概述
	>> 关联容器不支持顺序容器的位置相关的操作,如push_front,push_back操作
	>> 关联容器的迭代器为双向迭代器
	
	$ 定义关联容器
		>> 形如：multimap<int> mimap(v.cbegin(), v.cend());定义关键字重复的set
	
	$ 关键字类型的要求
		>> 对于有序的关联容器,关键字类型必须定义元素比较的方法,默认情况使用"<"运算符比较
		>> 当自定义操作来代替关键字的默认比较运算符时,所提供的操作必须在关键字类型上定义一个严格弱序
		>> 严格弱序：可看做小于等于
		>> 关键字等价：存在两个关键字都不小于等于另一个,则这两个关键字称为等价,关联同一个元素
		>> 形如：multiset<Sales_data, decltype(func)*> bookstore表示用函数func进行元素的有序排列
	
	$ pair类型
		>> 标准库类型,定义在utility.h,保存两个类型不要求一样的数据成员,是用来生成特定类型的模板
		>> pair的数据成员是public,可以使用first、second进行访问
		>> p1 relop p2 按关系运算符进行比较,当p1 < p2 时为true
	    >> pair的初始化支持默认值初始化、列表初始化、make_pair的初始化

--------------------
11.3、关联容器操作
	$ 关联容器定义了三种额外的类型
		>> key_type：关键字类型
		>> mapped_type：关键字关联的类型(值)---只有map有该类型
		>> value_type：对于set,与key_type相同,对于map,为pair<const key_type, mapped_type>(容器元素)
	
	$ 关联容器迭代器
		>> 关联容器迭代器解引用获得是value_type类型
		>> set的元素都是const类型的,只读不能改变
		>> map、set都支持begin()和end()操作获取迭代器iterator
		>> 有序的关联迭代器排列是按照字典序排列,遍历按照升序遍历
		>> 关联容器一般不适用泛型算法,因为：1、关联容器中的关键字为const 2、关键字一般无法快速查找容器元素
		
	$ 添加元素
		>> 关联容器支持成员函数insert用于向元素插入一个元素或一个元素范围
		>> insert支持花括号列表插入和迭代器范围插入
		>> 对于map,插入的元素必须是pair类型
		>> 对于不重复元素的关联容器的插入：
			insert(v)返回的是一个pair类型,first成员为插入元素迭代器,second指示是否插入成功
			关键字存在容器中,则first为原值,second为false
	
	$ 删除元素
		>> erase支持三个版本：
		   % c.erase(p); //p为容器c中的真实存在的元素,返回void
		   % c.erase(b, e) //删除迭代b和e范围的元素,返回e
		   % c.erase(k)   //k为key_type类型,删除容器中k关联的元素,返回删除的元素个数
		
	$ map的下标操作
		>> set不支持下标操作
		>> map、unordered_map支持下标运算符和at函数
			% map的下标运算符为关键字,如果容器中不存在,则创建一个执行了值初始化的关联值组成的元素
			% c.at(k) //访问关键字为k的元素,如果不存在,则抛出异常
			% map的下标操作返回的是mapped_type的类型,是一个左值,可以读写
	
	$ 访问元素
		>> c.find返回一个指向第一个关键字为k的元素
		   % c.count返回一个关键字k的对于的元素个数
		   % c.lowr_bound(k)返回第一个不小于关键字k的元素
		   % c.upper_bound(k)返回第一个大于关键字k的元素
		   % c.equal_range(k)返回一个迭代器pair,pair的两个成员表示等于k的元素范围迭代器
		>> 对于有序的multi容器,同一关键字的元素是相邻存储的

--------------------
11.4、无序容器
	>> 定义4个无序关联容器,使用哈希函数和关键字类型的==运算符来组织元素
	>> 无序容器通过桶保存,计算关键字的哈希值,获取对应的桶,从而得到元素

	
==========================================================================================================	
第12章：动态内存
--------------------
12.1、动态内存与智能指针
	$ 动态内存的管理是通过一对运算符来完成：
		>> new分配
		>> delete释放
		
	$ 智能指针--属于模板(类型vector)
		>> shared_ptr类：
			% 定义形如：shared_ptr<string> p1;
			% 智能指针shared_ptr存在引用计数,当计数为0时,则会释放管理的内存
			% make_shared<T>(arg),创建一个指向类型为T,初始值为arg的对象的shared_ptr类
			% 拷贝或者赋值时,每个shared_ptr都会记录有几个指向相同对象的shared_ptr
			% 当shared_ptr指向的对象的引用计数为0时,会调用shared_ptr的析构函数来销毁指向的对象
			% 当返回一个shred_ptr时,会拷贝一个shared_ptr,并递增指向对象的引用计数

	$ 直接管理内存
		>> new分配的对象是默认初始化的(注：非值初始化),内置类型其值是未定义的
		>> new可以使用直接初始化方式进行初始化,新的标准支持列表初始化(花括号)
			% 形如 vector<int> *vec1 = new vector<int>{1,,2,3,4,5};
		>> 也可以增加一个空括号执行值初始化
			% 形如：int *pi = new int();  //pi指向值为0的int对象
		>> new分配的const的对象必须进行初始化
		>> 当内存使用完后,使用new进行分配会抛出bad_alloc的异常
			% 定位new：允许向new传递额外的参数,形如：int *p2 = new(nothrow) int;

	$ shared_ptr和new结合使用
		>> shared_ptr默认的构造函数是explicit的,即表明只能采用直接初始化而不能进行类型转换
			% 形如：share_ptr<int> pi(new int(42))才是合法的
		>> 智能指针默认使用delete释放所关联的对象
		>> 智能指针定义的get成员函数用于返回一个指向智能指针所关联对象的内置指针

	$ 智能指针和异常
		>> 智能指针可以自定义释放操作,形如
			% shared_ptr<type> p(q, func); // 创建一个q初始化指向type的对象的智能指针,释放时调用函数func进行释放
		>> reset不传递参数时,是销毁智能指针关联的对象,传递参数则是重新分配一个指向新对象的智能指针	
	
	$ unique_ptr
		>> what：某时刻只能有一个unique_ptr指向给定的对象
		>> how：定义一个unique_ptr需要将其绑定到一个new返回的指针上,且必须使用值初始化进行初始化
			% 不支持普通的拷贝和赋值
			% q.realease操作返回原来保存的指针后将其置空,不会释放内存
			% q.reset(p);将q原指向的对象释放,并重新指向p指向的对象
		>> 当一个unique_ptr将要销毁时,可以执行拷贝或者赋值,常用于函数返回
	
	$ weak_ptr
		>> what：不控制所指向对象生存期的智能指针,它指向一个由share_ptr管理的对象,但不会增加引用计数
		>> how：
			% 不能直接使用weak_ptr访问对象,应当使用w.lock返回一个share_ptr的指针
			% w.lock：当w.expired()返回ture时返回空share_ptr,否则返回一个指向w对象的shred_ptr
			% w.expired()：当w.usecount()返回0为true
			% w.usecount()：返回与w共享的shred_ptr的对象个数
	
--------------------
12.2、动态数组
	$ new和数组
		>> 分配一个对象数组
			% 形如：int *pi = new int[get_size()]; //pi指向分配的第一个int
		>> 分配的得到是一个数组对象的元素类型指针,因此动态数组并不是数组类型,不能使用begin和end
		>> 分配的动态数组默认初始化,可以使用圆括号或者花括号列表进行值初始化
		>> new分配一个空的动态数组是合法的,但返回的指针类似于尾后迭代器,不可解引用
		>> 释放动态数组
			% 形如：delete [] p;表示释放的是一个p指向的动态数组
		>> unique_ptr可以管理new分配的动态数组
			% 形如：unique_ptr<int[]> u(new int[10]);
			% 当使用u.realease时会释放动态数组
		>> share_ptr不支持管理动态数组,并且未定义下标运算符,如果必须使用,则需要重载share_ptr的删除器
	
	$ allocator类
		>> what：用于new在分配内存的同时也构造了对象的问题,标准库的allocator类将分配内存和构造对象分离
			% 分配的内存是原始的,未构造的
			% 类型与vector,属于模板
		>> how：
			% 形如：allocator<string> alloc; auto const p = alloc.allocate(n); //分配n个未初始化的string
			% 调用：alloc.construct(p, "hi");进行对象的构造
			% 调用：alloc.destroy(p);调用对象的析构函数进行对象的销毁
			% 调用：alloc.deallocate(p, n)进行内存的释放
			% allocator还支持其他的算法操作：uninitialized_copy和uninitialized_fill操作用于拷贝和填充未构造的内存
						
	
==========================================================================================================	
第13章：拷贝控制
	>> 拷贝控制操作：一个类显式或者隐式地指定了类的对象进行拷贝、移动、赋值和销毁时做什么,包括五种成员函数：
		% 拷贝构造函数：定义了用同类型的另一个对象初始化本对象时做什么
		% 拷贝赋值运算符：定义了将一个对象赋予同类型的对象时做什么
		% 移动构造函数：同拷贝构造函数
		% 移动赋值运算符：同拷贝赋值运算符
		% 析构函数：定义对象销毁做什么
--------------------
13.1、拷贝、赋值与销毁
	$ 拷贝构造函数
		>> what：构造函数的第一个参数是自身类类型的引用,且任何额外参数都有默认值,此构造函数为拷贝构造函数
			% 特点：会存在隐式的转换,因此一般不应该是explicit的;参数一般为const
			% 拷贝初始化采用拷贝构造函数或者是移动构造函数实现
	
	$ 拷贝赋值运算符
		>> 重载运算符：本质上为函数,其名字由关键字operator后接表示要定义的运算符符号组成
			% 形如：<返回类型 operator=(参数列表)>
			% 针对赋值运算符,返回值一般为左侧运算对象的引用
			% 若一个运算符为类的成员函数,其左值对象就绑定到隐式的this参数
		>> 合成拷贝赋值运算符：编译器定义的拷贝赋值运算符
	
	$ 析构函数
		>> 析构函数释放对象使用的资源,并销毁对象的非static数据成员
			% 形如：~Foo();   ## ~接类名构成,无参数,无返回值
			% 对于给定的一个类,只会有唯一的一个析构函数
		>> 析构函数如何工作
			% 先执行函数体,再销毁成员,成员按初始化顺序的逆序销毁(初始化顺序为成员在类中的顺序)
			% 析构部分是隐式的
			% 注意：隐式销毁一个内置指针不会delete它所指向的对象
			% 容器的析构函数会销毁容器中的元素
		>> 合成析构函数
			% 当类中未指定析构函数时,编译器会为它定义一个合成析构函数
			% 合成析构函数的函数体为空
	
	$ 三/五法则
		>> 需要析构函数的类也需要拷贝构造函数和拷贝赋值操作运算符
			% 因为默认的合成拷贝构造函数只是简单的赋值操作,这对某些new的对象可能会被类的析构函数释放,导致资源无效
		>> 需要拷贝操作的类型也需要赋值操作,反之也是一样
		
	$ 使用=default
		>> 当使用=default时默认由编译器生成合成拷贝控制成员
		>> 如果在类中用default修饰成员的声明时,合成的函数将隐式声明为内联的
	
	$ 阻止拷贝
		>> 如iostream类,为避免多个对象写入或读取相同的IO缓冲,因此需要阻止拷贝
		>> why:
			% 如果不定义拷贝控制成员函数,则类还是由编译器生成合成的版本
		>> 删除的函数
			% 虽然声明了,但是不能以任何的方式使用
			% 形如：class(const &classs) = delete; //在参数列表后加上=delete
			% =delete 必须出现在函数第一次声明的时候
			% 任何函数都可以指定 =delete
			% 析构函数不能指定 =delete
			% 当类中存在不可能拷贝、赋值或者销毁成员时,则类的合成拷贝控制成员就被定义为删除
		>> private拷贝控制
			% c++11之前,当拷贝构造函数和拷贝赋值运算符声明为private时,是用于阻止拷贝的
			% 在声明为private并且不定义拷贝构造函数和拷贝赋值运算符时,友元和成员函数也将无法进行拷贝
	
--------------------
13.2、拷贝控制和资源管理	
	>> 通过定义拷贝操作,使类的行为看起来像一个值或者指针
		% 类像值,则说明拷贝类时,类与类之间是独立的
		% 类像指针,则说明类是共享状态,拷贝类时共用相同的底层数据
	
	$ 行为像值的类
		>> 要求每个对象都有自己的一份拷贝
		>> 赋值运算符
			% 如果将一个对象赋予它自身,赋值运算符必须能正常工作
			% 大多数赋值运算符组合了析构函数和构造函数的工作(释放原来的对象,构造新的对象)
			% 编写正确的赋值运算符的一个模式是：先构造临时变量拷贝右侧运算对象,再释放左侧运算对象
	
	$ 行为像指针的类
		>> 实现行为像指针的类有两种方式：shared_ptr、和引用计数
		>> 引用计数
			% 计数器不能作为类的成员
	
--------------------
13.3、交换操作
	>> 用于交换两个元素,一般管理资源的类通常都会存在swap成员函数
	>> 注意：标准库中同样存在swap函数,因此在调用时,可能调用的是标准库的swap
		% 建议在自定义的swap函数中增加语句：using std:swap;
		% 在自定义的swap函数中,如果增加了上述语句,则会根据参数进行匹配合适的swap函数
	
--------------------
13.4、示例
	>> 自定义的拷贝赋值运算符一定要考虑自赋值的情况
	>> 自定义的swap函数是否能够提高性能(避免重新申请内存),否则没必要重新定义
	
--------------------
13.5、动态内存管理
	>> 对于string类,新的标准库提供了两种机制,避免string的拷贝
		% 移动构造函数,只移动不拷贝
		% move标准库函数：通常不为move提供using声明,使用std::move
			std::move(string s);返回string的移动构造对象,string管理的内存不会被拷贝,只会被新元素接管

--------------------
13.6、对象移动
	>> 新标准支持,移动会相对于拷贝提示性能,并且某些类并不支持拷贝,如unique_ptr和IO类
	
	$ 右值引用
		>> 右值引用就是必须绑定到右值的引用,使用&&来获得右值引用
			% 只能绑定到一个将要销毁的对象
			% 形如：int &&rr = i * 42;
		>> 左值长久,而右值短暂
			% 左值有持久的状态,而右值要么是字面常量,要么是在表达式求值过程中的临时对象
		>> 变量是左值
			% 右值引用不能绑定到一个右值引用类型上
		>> 标准库move函数
			% move函数用于将一个左值转换成右值引用类型
			% 形如：int &&rr3 = std::move(rr1);
			% 调用move后,意味着只能对rr1进行赋值或者销毁,而不能使用它
	
	$ 移动构造函数和移动赋值函数
		>> 移动构造函数
			% 第一个参数为该类类型的右值引用,其它参数都必须有默认实参
			% 移动完成后,源对象不能再指定被移动的资源,意味着源对象调用析构函数是无害的
			% 移动操作一般不应抛出异常,使用noexcept(新标准)在函数的列表后指定,且声明和定义都需要指定
			% 不抛出异常的原因是因为：避免抛出异常时会达不到某些标准库容器在异常后要求的行为
		>> 移动赋值运算符
			% 需要检测自赋值的情况(一般通过检测传递的右值引用地址是否与this一致)
		>> 合成的移动操作
			% 当类中不存在任何自定义的拷贝控制成员,且每个非static的类成员都可以移动时,编译器才会合成移动操作
			% 内置类型或者定义了移动操作的类都是可移动的
			% 当定义了移动构造函数或移动赋值操作,则合成拷贝构造函数和拷贝赋值运算符会被定义为删除的
		>> 当同时定义了拷贝和移动操作,则进行合适的匹配,左值匹配拷贝操作,右值匹配移动操作
		>> 当只定义了拷贝构造函数时,传递的是右值引用,则同样可以使用拷贝构造函数
			% 原因：int &&rr2可以转化成 const int &r1;
		>> 移动迭代器(新标准下的标准库支持)
			% 与一般迭代器解引用返回左值不同,移动迭代器解引用返回右值引用
			% 使用标准库函数：make_move_iterator接受一个普通迭代器,返回一个移动迭代器
	
	$ 右值引用和成员函数
		>> 通常可以给一个函数定义两个版本：
			% func(const T&); //传递一个const的左值引用,进行拷贝
			% func(T&&);	  //传递一个右值引用,进行移动
	
	
==========================================================================================================	
第14章：重载运算与类型转换
--------------------
14.1、基本概念
	$ 重载的运算符
		>> 具有特殊的名字,由关键字operator和其后要定义的运算符号组成,包含返回类型,参数列表和函数体
			% 参数和该运算符作用的运算对象数量一样多
			% 成员运算符函数左侧运算对象绑定this指针上
			% 除了重载后的operator之外,重载的运算符不能含有默认实参
			% 运算符作用与内置类型时,无法进行重载,只能作用类类型才能重载
			% 一般情况下,不重载逗号,取地址,逻辑与和逻辑或运算符--重载后的原求值顺序无法保留
		>> 运算符重载为成员函数
			% 左侧对象必须是运算符所属类的一个对象
			% 改变对象状态通常应该重载为成员函数
			% 赋值、下标、调用、成员访问箭头(->)运算符必须是成员
			
--------------------
14.2、输入和输出运算符
	$ 重载输出运算符<<
		>> 重载的输出运算符有以下几点：
			% 第一个形参一般为非常量的ostream(会改变状态并且不允许赋值),第二个形参一般为常量的引用
			% 返回值为ostream形参
			% 输出运算符不应该打印换行符
			% 输入输出运算符必须是非成员函数
			% IO运算符一般会读写类的非公有数据成员,因此IO运算符一般被定义为类的友元
			
	$ 重载输入运算符>>
		>> 重载的输入运算符有以下几点：
			% 第一个形参为将要读取流的引用,第二个形参为读入到的非常量对象的引用,返回给定流的引用
			% 输入运算符需要检测是否失败

--------------------
14.3、算术和关系运算符
	>> 通常定义为非成员函数,不改变操作对象状态,因此形参为常量的引用
	
	$ 相等运算符
		>> 类的设计中如果需要判断两个对象是否一致,显然定义成operator==比较合适,避免重新使用新的函数名字
		>> 定义了operator==时也应该定义operator!=操作
		
	$ 关系运算符
		>> 只有存在一种逻辑可靠的<定义,才应该考虑定义<运算符
		>> 若类中包含==,则只有在<定义和==产生的结果一致时才定义<运算符

--------------------
14.4、赋值运算符
	>> 除了构造的拷贝赋值和移动赋值,还可以定义其他的赋值操作,如vector的花括号列表赋值操作
	>> 赋值运算符必须是成员函数
	>> 赋值运算符应该返回左侧运算对象的引用

--------------------
14.5、下标运算符
	>> 形如：operator[],必须是成员函数
	>> 返回值一般为所访问元素的引用
	>> 通常定义两个版本,一个返回普通引用,一个是类的常量成员(参数列表后const修饰)并返回常量引用

--------------------
14.6、递增和递减运算符
	>> 递增和递减的运算符重载后应该支持前置和后置两个版本
		% 为了区分,后置版本接受一个额外的int类型的形参(不使用)
		% 前置应该返回递增或者递减后的对象引用
		% 后置返回递增或者递减前的原对象的值

--------------------
14.7、成员访问运算符
	>> 重载的->必须返回类的指针或者自定义了箭头运算符的某个类的对象

--------------------
14.8、函数调用运算符
	>> 当类定义重载了函数运算符,则可以像调用函数一样调用这个类
		% 形如：abs为一个类,且重载了函数运算符,则可以直接调用 int i = abs(a);
	>> 若类定义了调用运算符,则这个类的对象称为函数对象
	
	$ lambda是函数对象
		>> lambda类似一个未命名的,只有一个函数运算符的类
		>> lambda的捕获的变量如果是值的方式,则要求lambda产生的类中包含该成员
		
	$ 标准库定义的函数对象
		>> 标准库定义了一组表示算法运算符、关系运算符和逻辑运算符的类
		>> 比较运算符不能用来比较指针类型,通常使用less进行比较
			% 形如：less<string *>()(ps1, ps2)

	$ 可调用对象与function
		>> 因为可能调用对象的类型不一致,但调用形式是相同的.
			% 如：int(int, int) //调用对象可以执行不一样的操作,但是调用形式都是一致的
		>> 为了调用合适的调用对象,引入了函数表
			% 函数表：用于存储指向这些可调用对象的“指针”
			% 函数表可以通过map实现
		>> 函数表中存储的是指针,而lambda表达式以及类重载的运算符都不属于指针,因此引入了function标准库类型
			% 新的标准库类型
			% 形如：function<int(int, int)> f1 = add;

--------------------
14.9、重载、类型转换与运算符
	$ 类型转换运算符
		>> 类的一种特殊成员函数,负责将一个类类型的值转换成其他类型
			% 形如：operator int() const; //表示将类类型转换成int
			% 类型转换运算符无返回值、形参和函数体,一般定义为const成员
			% 类很少提供类型转换运算符,因为上述描述的均是隐式的类型转换,会在很多时候导致误解
		>> 显式的类型转换运算符
			% 通过explicit修饰转换运算符,将转换运算强制成了显式的转换
			% 通过static_cast<int>进行显式的转换,形如 static_cast<int>(si) + 3; //类si强制转换成int
			% 当表达式被用作条件时,显式的类型转换也会隐式的执行
	
	$ 避免有二义性的类型转换
		>> 定义了多种向同一类型转换的方式
		>> 多个转换运算符的参数类型间都可以相互转换
	
	$ 函数匹配与重载运算符
		>> 重载后的运算符采用的是通用的函数匹配规则


==========================================================================================================	
第15章：面向对象程序设计
--------------------
15.1、OOP：概述
	>> OOP：面向对象程序设计的核心思想是数据抽象、继承和动态绑定
		% 数据抽象：类
		% 继承：定义相似的类型并对其相似关系建模
		% 动态绑定：在一定程度上忽略类型的区别,以统一的方式使用它们的对象
	$ 继承
		>> 基类
			% 通过继承联系在一起的类构成层次关系中的根部称为基类
			% 定义了在层次关系中所有类共同拥有的成员
		>> 派生类
			% 其他从基类直接或间接继承得到的类称为派生类
			% 派生类中定义了各自特有的成员
			% 形如：class f1: public f2 { public: int func1(int) override; }
			  表示f1继承了f2，其中override表示函数func1为虚函数
		>> 虚函数
			% 对于某些函数,基类希望其他的派生类各自定义适合自身的版本,此函数称为虚函数
			% 形如：virtual int func(int); //关键字virtual表示此函数为虚函数
			
	$ 动态绑定
		>> 在运行时根据实参的类型不同选择函数的版本,称为动态绑定或者运行时绑定
		
--------------------
15.2、定义基类和派生类
	$ 定义基类
		>> 基类通常应该定义一个虚析构函数
		>> 虚函数用来表示基类希望派生类自定义函数进行覆盖
			% 除了构造函数之外的非静态函数都可以是虚函数
			% virtual关键字只能出现在类的声明中,类外部函数定义不能使用
		>> 派生类的访问控制
			% 正常情况,只能访问基类的公有成员
			% 当基类使用关键字protected则表示派生类可以访问该成员
	
	$ 定义派生类
		>> 派生类需要重新在类中声明需要覆盖的那些函数
		>> 当在派生列表中使用public时,在任何需要基类的引用或者指针都能使用派生类的对象
		>> 只继承一个类的形式成为“单继承”
		>> 如果不覆盖虚函数,派生类则会直接继承基类的虚函数版本
		>> 如果覆盖虚函数,则可以在新标准下增加override关键字
			% override关键在形参列表后或者const关键字之后
		>> 基类的指针或者引用可以绑定到派生类的基类部分上,实现派生类到基类的类型转换
		>> 对于派生类中的基类成员,必须使用基类的构造函数进行初始化
		>> 若基类中定义了一个静态成员,则在整个继承中,只存在该成员的唯一定义
		>> 派生类的声明只包含类名,不包含派生列表
		>> 如果不希望其他类继承它,则在c++11的标准下支持如下格式
			% 形如：class last final {.....};类名后加final表示类last不支持继承
	
	$ 类型转换和继承
		>> 指针、引用、智能指针都支持基类绑定到其派生类的对象上
		>> 基类向派生类的转换是不被允许的,除非使用static_cast进行转换
		>> 当使用一个派生类为一个基类对象初始化或者赋值时,只有派生类中的基类部分会被执行操作
		
--------------------
15.3、虚函数
	>> 虚函数无论是否使用都必须被定义
	>> 多态性：OOP的核心思想
		% 具有继承关系的多个类型称为多态类型
	>> 派生类的函数如果覆盖了继承而来的虚函数,则它的形参、返回类型必须与继承的基类函数一致
		% 例外：返回类型是类的本身的指针或者引用
	>> 关键字overrride表示派生类中的函数是覆盖继承而来的虚函数
	>> 虚函数支持默认实参
		% 默认实参值取决于本次调用的静态类型决定,即使后续运行时绑定到了别的类型也是如此
	>> 使用作用域运算符可以实现避免虚函数的动态绑定
		% 形如：int a = basep->BASE::func(12); //basep指向的静态类型为BASE,动态类型是什么
		  调用的都是BASE类型的函数
    
--------------------
15.4、抽象基类
	>> 纯虚函数
		% 表明此虚函数无任何意义
		% 形如：int func(int) const = 0; // 表示func为纯虚函数
		% =0 只能出现在类的内部,而如果想要定义纯虚函数,则只能在类外
	>> 抽象基类
		% 含有纯虚函数(或者未经覆盖直接继承)的类称为抽象基类
		% 抽象基类不能直接创建一个抽象基类的对象
		
--------------------
15.5、访问控制与继承
	>> 受保护的成员
		% 使用关键字protected表示该成员只允许派生类的成员或者派生类的友元访问
		% 派生类的成员或者派生类的友元只能通过派生类对象来访问基类受保护的成员
	>> 访问权限
		% 派生访问说明符的目的是控制派生类用户对于基类成员的访问权限,不影响派生类成员的访问权限
		% 派生类的派生类同样受派生访问说明符的访问控制
	>> 友元与继承
		% 友元不能进行传递,也不能继承
		% 友元能够访问其类下的派生类的继承成员,但不能访问其派生类自定义的成员
	>> 修改某些成员的访问级别
		% 使用using声明可以修改派生类中继承成员的访问级别
		% 形如：class D::private B{ public: using B::size(); protected:using n; } 
		% 上述的方式表明：类D的用户可以访问size,派生类的成员和友元可以访问n
	>> 默认的继承保护级别
		% class关键字定义的派生类默认是私有继承的,struct则是公有继承的
		% clase和struct的唯一差别在于：默认成员的访问说明符以及默认的派生访问说明符
	>> 派生类到基类的转换
		% 只有当公有的继承时,用户代码才能使用派生类到基类的转换
		% 不管派生类D以什么方式继承B,其D的成员或者友元都可以执行派生类到基类的转换
		% 当D是以公有或者受保护的方式继承与B,则D的派生类才能执行D到B的转换,私有的继承则不能
		
--------------------
15.6、继承中的作用域		
	>> 当存在继承关系时,派生类的作用域嵌套在其基类的作用域之内
	>> 一个对象、引用或者指针,其静态类型决定了那些成员是可见的,即使与动态类型不一致的情况
	>> 派生类中重用定义直接基类或间接基类的名字时,内层作用域覆盖外层作用域
		% 可以通过作用域运算符使用被覆盖的成员

--------------------
15.7、构造函数和拷贝控制
	$ 虚析构函数
		>> 在基类中定义虚析构函数,以便释放对象时执行正确的析构函数
		>> 在基类中定义了虚析构函数,则不一定需要拷贝和赋值操作
		>> 在基类中定义了虚析构函数,则其和其派生类将会使得编译器不会为其合成移动操作
		
	$ 合成拷贝控制与继承
		>> 构造函数在派生类中会调用基类的构造函数初始化基类部分成员
			% 同样的,拷贝构造函数和析构函数也是如此
		>> 派生类中删除的函数与基类的关系
			% 基类的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的或者不可访问的,则派生类
			  对应的也是被删除的
			% 基类存在不可访问或者删除的析构函数,则派生类中的默认和拷贝函数将是被删除的
			% 基类中的析构函数是不可访问的或者删除的,则派生类的移动构造函数也将是删除的
		>> 移动操作与继承
			% 当派生类需要执行移动操作时,必须在其基类显示定义移动操作以及拷贝操作
	
	$ 派生类的拷贝控制成员
		>> 定派生类中定义了移动或者拷贝函数时,必须也要移动或者拷贝基类部分成员,赋值运算符也是如此
			% 与析构函数不同,析构函数只负责销毁派生类自己分配的资源
		>> 定义派生类的拷贝或移动构造函数
			% 若在派生类想拷贝或者移动基类部分,则要在构造函数的初始值列表中显示调用基类的拷贝或移动构造函数
		>> 派生类赋值运算符
			% 派生类的赋值运算符必须显式地为基类部分赋值
		>> 派生类的析构函数调用顺序与继承方向相反
		>> 如果构造函数或者析构函数调用了虚函数,则调用的是所属类型的虚函数
		
	$ 继承的构造函数
		>> 使用using声明表示派生类继承了基类的构造函数
			% 形如：using BASE::BASE(); //继承了类BASE的构造函数base
			% 继承了基类的构造函数后,其派生类的成员执行默认初始化
			% using作用在构造函数不会改变该构造函数的访问级别
		>> 构造函数继承
			% 派生类继承基类构造函数的explicit和constexpr属性
			% 派生类不会继承基类构造函数的默认实参,相反是得到多个基类的构造函数代替默认实参
			% 继承而来的构造函数不能别用户使用,只含有一个继承的构造函数时,编译器会合成一个默认构造函数
			% 默认、拷贝和移动构造函数不能被继承
		
--------------------
15.8、容器与继承
	>> 容器不允许保存于类型不符合的对象,当容器中保存的是基类类型时,添加的派生类对象将只保留基类部分
	>> 在容器中放置指针而非对象
		% 在容器存放具有继承关系的对象时,应选择指针或者只能指针类型

--------------------
15.9、示例
	>> 根据实际场景得到应该包含的操作
	>> 根据场景设计合适的基类和派生类的继承关系
	>> 定义接口类隐藏继承体系

==========================================================================================================	
第16章：模板与泛型编程
	>> 模板是泛型编程的基础,模板是一个创建类或函数的蓝图或者说公式
--------------------
16.1、定义模板
	$ 函数模板
		>> 函数模板就是一个公式,用来生成针对特定类型的函数版本
		>> 模板定义
			% template关键字开头,后跟一个【模板参数列表】,包含一个或者多个【模板参数】
			% 模板定义中,模板参数列表不能为空
			% 形如：template <typename T> int func(T &v1, T &v2) {......};
		>> 实例化函数模板
			% 编译器用函数实参来推断特定模板实参版本的函数的过程称为模板的实例
		>> 模板类型参数
			% 模板类型参数T可以用作返回值、函数参数类型、变量声明或类型转换
			% 类型参数T前必须使用关键字：typename或者class
		>> 非类型模板参数
			% 一个特定的类型名,而没有使用关键字typename或class
			% 整型的非类型参数的实参必须是常量表达式,指针或者引用的实参则必须是具有静态的生存周期
		>> 模板函数支持inline或者constexpr
			% 形如：template<typename T> inline T func(T&);
		>> 模板编译
			% 编译器只有在实例化模板(使用模板)时才生成代码

	$ 类模板
		>> 格式
			% 关键字template后接模板参数列表
			% 形如：template <typename T> class C1 {........};
		>> 实例化类模板
			% 使用类模板时,必须提供显式的模板实参列表
			% 形如：C1<int> c;
			% 注意：typename用在类型别名时,必须使用在类模板的类的定义里
				    格式：typedef typename int int_32;
		>> 类模板的成员函数
			% 成员函数可以定义在类内或者类外,类内默认为inline函数,类外则需要关键字template加模板参数列表
			% 形如：template <typename T> void C1<T>::member(int, int){......}；
			% 默认情况,类模板的成员函数只有在使用时才进行实例化
		>> 在类模板自己的作用域内使用类模板时,不需要提供模板实参
		>> 类模板和友元
			% 类与友元各自是否是模板是无关的
			% 当类模板内的友元非模板时,友元有权访问所有类模板的实例
			% 使用类模板之前,必须先声明,声明包括模板参数列表
			% 形如：类C的友元：template <typename T> friend class P; //表示P的所有实例都是每个类C的友元
			% 形如：类C的友元：friend class P1<T>; //表示C声明了共同通过T实例化P1为友元
			% 新标准中,模板类型参数可以声明为友元,形如：template <typename TYPE> class C{friend TYPE;};
		>> 模板类型别名
			% 实例化的类模板才能进行类型别名,形如 typedef C<string> strC;
			% 新标准下,允许为类模板定义一个类型别名,形如：template<typename T> useing twin = pair<T, T>;
		>> 类模板的静态成员
			% 对于类模板含有的静态成员,每个类实例化后都拥有其静态成员示例,相同类型的类模板共享静态成员
			
	$ 模板参数
		>> 作用域
			% 声明之后,至模板声明或者定义结束之前
			% 在模板内不能重用模板参数名(作为其他用途的名字)
		>> 使用类的类型成员
			% 注意：在类中,使用作用域运算符(::)来访问只有静态成员和类型成员
			% 当使用模板类型参数的类型成员时,应使用typename显式的说明
			% 形如：typename T::value_type func(T&);
		>> 默认模板实参(新标准支持为函数模板和类模板提供默认实参)
			% 使用：template <typename T, typename F = less<T>> func(T &v1, T &v2, F f=F()){.....};
		>> 当类使用<>则表示此类为类模板实例化而来,当使用空的<>时表示使用默认模板实参
		
	$ 成员模板
		% 普通类和类模板可以包含本身是模板的成员函数,这种成员称为成员模板,成员模板不能是虚函数
		
		>> 普通类的成员模板
			% 与普通的成员函数模板的声明和定义一致
		>> 类模板的成员模板
			% 在类模板外定义成员模板需要同时为类模板和成员模板提供模板参数列表
			% 形如：template<typename T> template<typename it> C<T>::C(it a)
		
	$ 控制实例化
		>> 显示实例化(新标准中支持)
			% what：为了解决多个独立的文件使用了相同模板时而生成多份相同的实例
			% how：
				声明：extern template class C<string>; //编译器遇到此语句时不会再实例化,但必须在别处有定义
				定义：template class C<string>; //编译遇到定义会实例化并生成代码
			% note：
				extern声明必须出现在任何使用此实例化的代码之前,否则还是会进行实例化
				类模板的实例化定义会实例该模板下所有的成员,而不是如普通的只有在使用时才进行实例化
				
	$ 效率与灵活性
		>>share_ptr与unique_ptr删除器
			% share_ptr的删除器可以在创建或者reset指针时传递给它一个可调用对象
			% unique_ptr对象类型的一部分,必须在定义时显式的提供
			
ss--------------------
16.2、模板实参推断
	% 从调用的函数实参来推断模板实参的过程称为模板实参推断
	
	$ 类型转换与模板类型实参
		>> 类型转换
			% 非const到const的转换是支持的
			% 数组或函数到对应类型的转换
			% 算术转换、派生类向基类的转换、用户定义的转换等
			% 注意：形参是一个引用时,数组不会转换成指针
		>> 使用相同的模板参数类型的函数形参
			% 当一个模板类型参数用作多个函数形参的类型时,传递的实参类型必须一致
			% 如果要想支持不同的实参类型,则需要定义不同的模板类型参数作为形参
			% 当函数参数类型不是模板参数,则对实参进行正常的实参到形参的类型转换
	
	$ 函数模板显示实参
		>> 指定显式模板实参
			% 显式模板：模板参数不定义无法由编译推断出来,必须由调用者提供一个显式模板实参
			% 格式：template <typename T1, typename T2, typename T3> T1 sum(T2,T3);
					指定：sum<long long>(int, long);
			% 显式模板实参按由左至右的顺序与对应的模板参数匹配
		>> 正常类型转换应用于显式指定的实参
			% 当指定了显式的实参后,对于调用可以进行正常类型的转换
	
	$ 尾置返回类型与类型转换
		>> 尾置返回类型用于在参数列表之后声明返回类型
			% 形如：template <typename It> auto fcn(It beg, It end) ->decltype(*beg){return *beg;};
			  decltype返回于beg表示的元素的类型的引用
		>> 使用remove_reference来获得元素类型
			% 形如：remove_reference<decltype(*beg)>::type //返回元素类型本身

	$ 函数指针和实参推断
		>> 当使用函数模板初始化一个函数指针或者为函数指针赋值,编译器使用指针的类型推断模板实参
		>> 只用当确定模板实参的唯一类型时实例化才能成功
	
	$ 模板实参推断和引用
		>> 
==========================================================================================================
第一章~第九章：
>> decltype(func)用于推断对象func的类型
>> decltype用于函数指针的别名创建,形如：typedef decltype(func) *FuncP 定义FuncP为指向func函数类型的函数指针
>> initializer_list<T> lst;用于函数的实参数量未知但是全部实参的类型相同
	% void error_msg(initializer_list<string> l){}
	% 可使用begin,end等通用操作
>> explicit用于限制构造函数执行隐式转换,只能采用直接初始化的方式(圆括号初始化)
>> 顶层const与底层const
	% 只有指针和引用才存在底层const
	% 顶层const表明指针变量是const,底层const表示指针所指对象为const
	% 引用的const为底层const
	% 默认存在的是顶层const,顶层const在转换时可以被忽略
>> 不完全类型
	% 在声明之后定义之前的类型称为不完全类型
	% 可以使用在指针或者引用

==========================================================================================================
第10章：泛型算法(绝多数的算法支持迭代器)
--------------------
10.3、定制操作
1、why(为什么要有定制操作)
# sort的排序算法默认使用元素类型的<运算符,但是可能需要其他的比较方式,因此需要重载sort

2、HOW(实现)
# 重载的sort函数接受第三个参数,引入"谓词"
	$ 谓词：
		>> 可调用的表达式,返回结果是一个能作为条件的值
		>> 分类：一个参数称为一元谓词,两个参数称为二元谓词	

# sort算法：接受一个迭代器范围,按照递增的顺序排列元素
		
# stable_sort算法：接受一个迭代器范围和谓词,维持相等元素的原有顺序

# find_if算法：接受一个迭代器范围和一元谓词,返回第一个使一元谓词返回非0的元素,不存在则返回尾迭代器

# for_each算法：接受一个迭代器范围和调用对象(lambda),对其输入序列调用此对象

# unique算法：使得每个单词只出现一遍,返回指向不重复区域之后一个位置的迭代器

# copy算法：形如copy(begin(a), end(a), b),将a的内容拷贝到b中

# find算法：形如find(c.begin, c.end, ','),在容器c中查找第一个字符','的元素，返回指向该元素的迭代器

# lambda表达式：
	$ 作用：表示一个可调用的代码单元(函数和函数指针就属于可调用对象),可以理解为一个无名字的内联函数
	
	$ 格式：[捕获列表] (参数列表) -> return type { 函数体 }
	
	$ 调用：与普通函数一致
	
	$ 注意：lambda不支持默认参数、lambda在函数体中可以直接使用定义在当前函数外的名字
	
	$ 参数：捕获列表用于指引lambda在内部包含访问局部变量所需的信息,多个可以用逗号分隔
	        只有在捕获列表中指定了才能在函数体中使用该变量
			
	$ 捕获：lambda在定义时就初始化了所捕获的变量,而不是在调用是进行初始化杀
		>> 值捕获：变量可拷贝,在定义时就发生了拷贝
		>> 引用捕获：使用引用的变量时实际上就是使用引用所绑定的变量,使用方式 [&a] {....;};
		
	$ 隐式捕获：由编译器根据lambda中的代码来推断我们要使用哪些变量，使用方式 [&/=] {....;};
		>> 其中捕获列表中的&表示引用捕获,=表示值捕获,
		>> 当隐式捕获和显式捕获混合使用时,捕获列表中的第一个元素必须是&/=,且显式捕获要与隐式捕获采用不同的方式
		
	$ 可变lambda：
		>> 对于值捕获,如果想要修改被捕获变量的值,应该加入关键字mutable,形如：[a] () mutable {++a;};
		>> 对于引用捕获,能否修改捕获变量的值取决于局部变量是否是const,只用非const才能修改
	
	$ 指定lambda返回类型
		>> 如果lambda函数体中有除了return以外的语句,则被编译器默认为返回值为void,即不返回
		>> 针对上述情况,需要指定返回类型,形如：[] (int i) -> int { if(i) return -i; };
		
# 标准库函数bind
	$ 作用：一个通用的函数适配器,用于解决某些时候某些函数的限制
	
	$ 使用格式形如：auto check6 = bind(check_size, _1, 6);
	  表示check6接受一个与check_size第一个参数一致的参数,当调用check6时传递的参数会传递到check_size
	  
	$ 在使用_1或形如_n的时候要包含命令空间：using namespace std::placeholders
	
	$ 在使用bind生成新的调用函数后
		>> 形如：auto g = bind(f, a, b, c, _2, d, _1);
	    >> 当调用g(X, Y)时即调用：f(a, b, c, Y, d, X);这样的使用方法称为：用bind重排参数顺序
	  
	$ 由于bind是拷贝参数的方式,但某些参数无法拷贝时,如ostream os,此时需要使用标准库ref函数返回给定的引用
	  而cref返回一个const的引用
		>> 形如：bind(print, ref(os), -1, '')
	  
--------------------	 
10.4、再探迭代器
1、迭代器类型
# 插入迭代器
	$ what：插入器是一种迭代适配器,接受一个容器,生成一个迭代器用于向给定的容器添加元素
	
	$ HOW：当向一个插入迭代器赋值时,即将该元素插入到当前位置上
	
	$ 类型：
		>> back_inserter创建一个使用push_back的迭代器,插入的元素调用c.push_back
		>> front_inserer创建一个使用push_front的迭代器,插入的元素调用c.push_front
		>> inserter创建一个insert的迭代器：接受第二个指向该容器的迭代器,表示将元素插入到该迭代器之前
	
	$ why(原理)：对于语句：
		auto it = insert(c, c.cbengin())：
		*it = val;
		类似于：
		auto it = c.insert(c.cbegin(),val);
		++it；
		
# iostream迭代器
	$ istream_iterator
		>> 使用>>来读取流,绑定的对象必须支持输入运算符
		>> 形如 istream_iterator<int> in(cin);表示从标准输入中读取int
		>> istream_iterator<int> eof 表示一个初始化为空,表示一个尾后迭代器
		>> istream_iterator绑定到一个流时，标准库并不保证迭代器立即从流读取数据
	  
	$ ostream_iterator
		>> ostream_iterator<int> out(os); out将int类型的值写到输出流os
		>> ostream_iterator<int> out(os, d); out将int类型的值写到输出流os,并在值后跟d,d为指向一个空字符结尾的字符串
	  
# 反向迭代器
	$ what：反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器
		>> forward_list不支持反向迭代器
		>> 调用rbegin、rend，或crbegin、crend成员函数获取反向迭代器
		
	$ HOW
		>> 当反向迭代器时想要转化成正向迭代器,则调用迭代器成员函数base,函数返回的迭代器与反向迭代器相邻
		
		
--------------------	 
10.5、泛型算法结构
	>> 根据算法的实现要求迭代器支持的操作类型不一致,因此引入了5类迭代器
1、5类迭代器
	>> 高层类别的迭代器支持低层类别迭代器的所有操作
	
	$ 输入迭代器
		>> 只读不写,单遍扫描,只能递增
		>> find、accumulate要求输入迭代器,而istream_iterator是一种输入迭代器
		>> 解引用出现在赋值运算符的右侧
	
	$ 输出迭代器
		>> 只写不读,单遍扫描,只能递增
		>> 解引用在出现在赋值运算符的左侧
	
	$ 前向迭代器
		>> 读写元素,只能在序列中沿一个方向移动
		
	$ 双向迭代器
	    >> 可以正向反向读写序列中的元素
		
	$ 随机访问迭代器
		>> 可以再常数时间内访问序列中的任意元素

2、算法形参模式
	>> 算法一般都包含有一个迭代器表示的输入范围
	>> 算法还可以接受一个假定目的位置的迭代器所绑定的容器足够容纳写入的元素
	>> 算法同样也可以接受第二个迭代器表示的范围

3、算法命名规范
	>> 接受谓词参数或者一般不接受额外参数的算法都是重载后的算法
	>> 形参个数相同,但是函数的命名不同,此类函数非重载版本(_if版本)
	>> 区分拷贝元素和不拷贝元素的版本(一般附加一个_copy)
		
--------------------	 
10.6、特定容器算法
	>> list(双向迭代器)、forward_list(前向迭代器)单独提供了一套特定的算法：
	   sort、erase、remove、merge、reverse、unique
	  
	>> splice算法没有通用,都是定制算法,用于移动另一链表元素到链表中
	
	>> 链表实现的特定版本算法会改变容器,而通用算法一般不会

==========================================================================================================	
第11章：关联容器
	>> what：1.与顺序容器为同一级,但是从根本上不相同,保存和访问容器中的元素是按照关键字来进行
			 2.支持高效的关键字查找和访问,map和set类型是最重要的两个关联容器
			 
	>> map：元素为key-value对;
	
	>> set：每个元素只包含一个关键字
	
	>> 关键字重复的关联容器包含multi,无序的关联容器以unordered开头
	
	>> 无序的容器使用哈希函数来组织元素
	
--------------------
11.1、使用关联容器
	$ map
		>> 创建：map<string, size_t> word_count;
		>> map中的元素为pair类型的对象,可以使用first表示关键字,second表示值
		
	$ set
		>> 创建：set<string> exclude = {"hi", "hello"}
		>> 判断是否在set中,调用：exclude.find(string word),找到返回对应元素的迭代器,否则返回尾后迭代器
	
--------------------
11.2、关联容器概述
	>> 关联容器不支持顺序容器的位置相关的操作,如push_front,push_back操作
	>> 关联容器的迭代器为双向迭代器
	
	$ 定义关联容器
		>> 形如：multimap<int> mimap(v.cbegin(), v.cend());定义关键字重复的set
	
	$ 关键字类型的要求
		>> 对于有序的关联容器,关键字类型必须定义元素比较的方法,默认情况使用"<"运算符比较
		>> 当自定义操作来代替关键字的默认比较运算符时,所提供的操作必须在关键字类型上定义一个严格弱序
		>> 严格弱序：可看做小于等于
		>> 关键字等价：存在两个关键字都不小于等于另一个,则这两个关键字称为等价,关联同一个元素
		>> 形如：multiset<Sales_data, decltype(func)*> bookstore表示用函数func进行元素的有序排列
	
	$ pair类型
		>> 标准库类型,定义在utility.h,保存两个类型不要求一样的数据成员,是用来生成特定类型的模板
		>> pair的数据成员是public,可以使用first、second进行访问
		>> p1 relop p2 按关系运算符进行比较,当p1 < p2 时为true
	    >> pair的初始化支持默认值初始化、列表初始化、make_pair的初始化

--------------------
11.3、关联容器操作
	$ 关联容器定义了三种额外的类型
		>> key_type：关键字类型
		>> mapped_type：关键字关联的类型(值)---只有map有该类型
		>> value_type：对于set,与key_type相同,对于map,为pair<const key_type, mapped_type>(容器元素)
	
	$ 关联容器迭代器
		>> 关联容器迭代器解引用获得是value_type类型
		>> set的元素都是const类型的,只读不能改变
		>> map、set都支持begin()和end()操作获取迭代器iterator
		>> 有序的关联迭代器排列是按照字典序排列,遍历按照升序遍历
		>> 关联容器一般不适用泛型算法,因为：1、关联容器中的关键字为const 2、关键字一般无法快速查找容器元素
		
	$ 添加元素
		>> 关联容器支持成员函数insert用于向元素插入一个元素或一个元素范围
		>> insert支持花括号列表插入和迭代器范围插入
		>> 对于map,插入的元素必须是pair类型
		>> 对于不重复元素的关联容器的插入：
			insert(v)返回的是一个pair类型,first成员为插入元素迭代器,second指示是否插入成功
			关键字存在容器中,则first为原值,second为false
	
	$ 删除元素
		>> erase支持三个版本：
		   % c.erase(p); //p为容器c中的真实存在的元素,返回void
		   % c.erase(b, e) //删除迭代b和e范围的元素,返回e
		   % c.erase(k)   //k为key_type类型,删除容器中k关联的元素,返回删除的元素个数
		
	$ map的下标操作
		>> set不支持下标操作
		>> map、unordered_map支持下标运算符和at函数
			% map的下标运算符为关键字,如果容器中不存在,则创建一个执行了值初始化的关联值组成的元素
			% c.at(k) //访问关键字为k的元素,如果不存在,则抛出异常
			% map的下标操作返回的是mapped_type的类型,是一个左值,可以读写
	
	$ 访问元素
		>> c.find返回一个指向第一个关键字为k的元素
		   % c.count返回一个关键字k的对于的元素个数
		   % c.lowr_bound(k)返回第一个不小于关键字k的元素
		   % c.upper_bound(k)返回第一个大于关键字k的元素
		   % c.equal_range(k)返回一个迭代器pair,pair的两个成员表示等于k的元素范围迭代器
		>> 对于有序的multi容器,同一关键字的元素是相邻存储的

--------------------
11.4、无序容器
	>> 定义4个无序关联容器,使用哈希函数和关键字类型的==运算符来组织元素
	>> 无序容器通过桶保存,计算关键字的哈希值,获取对应的桶,从而得到元素

	
==========================================================================================================	
第12章：动态内存
--------------------
12.1、动态内存与智能指针
	$ 动态内存的管理是通过一对运算符来完成：
		>> new分配
		>> delete释放
		
	$ 智能指针--属于模板(类型vector)
		>> shared_ptr类：
			% 定义形如：shared_ptr<string> p1;
			% 智能指针shared_ptr存在引用计数,当计数为0时,则会释放管理的内存
			% make_shared<T>(arg),创建一个指向类型为T,初始值为arg的对象的shared_ptr类
			% 拷贝或者赋值时,每个shared_ptr都会记录有几个指向相同对象的shared_ptr
			% 当shared_ptr指向的对象的引用计数为0时,会调用shared_ptr的析构函数来销毁指向的对象
			% 当返回一个shred_ptr时,会拷贝一个shared_ptr,并递增指向对象的引用计数

	$ 直接管理内存
		>> new分配的对象是默认初始化的(注：非值初始化),内置类型其值是未定义的
		>> new可以使用直接初始化方式进行初始化,新的标准支持列表初始化(花括号)
			% 形如 vector<int> *vec1 = new vector<int>{1,,2,3,4,5};
		>> 也可以增加一个空括号执行值初始化
			% 形如：int *pi = new int();  //pi指向值为0的int对象
		>> new分配的const的对象必须进行初始化
		>> 当内存使用完后,使用new进行分配会抛出bad_alloc的异常
			% 定位new：允许向new传递额外的参数,形如：int *p2 = new(nothrow) int;

	$ shared_ptr和new结合使用
		>> shared_ptr默认的构造函数是explicit的,即表明只能采用直接初始化而不能进行类型转换
			% 形如：share_ptr<int> pi(new int(42))才是合法的
		>> 智能指针默认使用delete释放所关联的对象
		>> 智能指针定义的get成员函数用于返回一个指向智能指针所关联对象的内置指针

	$ 智能指针和异常
		>> 智能指针可以自定义释放操作,形如
			% shared_ptr<type> p(q, func); // 创建一个q初始化指向type的对象的智能指针,释放时调用函数func进行释放
		>> reset不传递参数时,是销毁智能指针关联的对象,传递参数则是重新分配一个指向新对象的智能指针	
	
	$ unique_ptr
		>> what：某时刻只能有一个unique_ptr指向给定的对象
		>> how：定义一个unique_ptr需要将其绑定到一个new返回的指针上,且必须使用值初始化进行初始化
			% 不支持普通的拷贝和赋值
			% q.realease操作返回原来保存的指针后将其置空,不会释放内存
			% q.reset(p);将q原指向的对象释放,并重新指向p指向的对象
		>> 当一个unique_ptr将要销毁时,可以执行拷贝或者赋值,常用于函数返回
	
	$ weak_ptr
		>> what：不控制所指向对象生存期的智能指针,它指向一个由share_ptr管理的对象,但不会增加引用计数
		>> how：
			% 不能直接使用weak_ptr访问对象,应当使用w.lock返回一个share_ptr的指针
			% w.lock：当w.expired()返回ture时返回空share_ptr,否则返回一个指向w对象的shred_ptr
			% w.expired()：当w.usecount()返回0为true
			% w.usecount()：返回与w共享的shred_ptr的对象个数
	
--------------------
12.2、动态数组
	$ new和数组
		>> 分配一个对象数组
			% 形如：int *pi = new int[get_size()]; //pi指向分配的第一个int
		>> 分配的得到是一个数组对象的元素类型指针,因此动态数组并不是数组类型,不能使用begin和end
		>> 分配的动态数组默认初始化,可以使用圆括号或者花括号列表进行值初始化
		>> new分配一个空的动态数组是合法的,但返回的指针类似于尾后迭代器,不可解引用
		>> 释放动态数组
			% 形如：delete [] p;表示释放的是一个p指向的动态数组
		>> unique_ptr可以管理new分配的动态数组
			% 形如：unique_ptr<int[]> u(new int[10]);
			% 当使用u.realease时会释放动态数组
		>> share_ptr不支持管理动态数组,并且未定义下标运算符,如果必须使用,则需要重载share_ptr的删除器
	
	$ allocator类
		>> what：用于new在分配内存的同时也构造了对象的问题,标准库的allocator类将分配内存和构造对象分离
			% 分配的内存是原始的,未构造的
			% 类型与vector,属于模板
		>> how：
			% 形如：allocator<string> alloc; auto const p = alloc.allocate(n); //分配n个未初始化的string
			% 调用：alloc.construct(p, "hi");进行对象的构造
			% 调用：alloc.destroy(p);调用对象的析构函数进行对象的销毁
			% 调用：alloc.deallocate(p, n)进行内存的释放
			% allocator还支持其他的算法操作：uninitialized_copy和uninitialized_fill操作用于拷贝和填充未构造的内存
						
	
==========================================================================================================	
第13章：拷贝控制
	>> 拷贝控制操作：一个类显式或者隐式地指定了类的对象进行拷贝、移动、赋值和销毁时做什么,包括五种成员函数：
		% 拷贝构造函数：定义了用同类型的另一个对象初始化本对象时做什么
		% 拷贝赋值运算符：定义了将一个对象赋予同类型的对象时做什么
		% 移动构造函数：同拷贝构造函数
		% 移动赋值运算符：同拷贝赋值运算符
		% 析构函数：定义对象销毁做什么
--------------------
13.1、拷贝、赋值与销毁
	$ 拷贝构造函数
		>> what：构造函数的第一个参数是自身类类型的引用,且任何额外参数都有默认值,此构造函数为拷贝构造函数
			% 特点：会存在隐式的转换,因此一般不应该是explicit的;参数一般为const
			% 拷贝初始化采用拷贝构造函数或者是移动构造函数实现
	
	$ 拷贝赋值运算符
		>> 重载运算符：本质上为函数,其名字由关键字operator后接表示要定义的运算符符号组成
			% 形如：<返回类型 operator=(参数列表)>
			% 针对赋值运算符,返回值一般为左侧运算对象的引用
			% 若一个运算符为类的成员函数,其左值对象就绑定到隐式的this参数
		>> 合成拷贝赋值运算符：编译器定义的拷贝赋值运算符
	
	$ 析构函数
		>> 析构函数释放对象使用的资源,并销毁对象的非static数据成员
			% 形如：~Foo();   ## ~接类名构成,无参数,无返回值
			% 对于给定的一个类,只会有唯一的一个析构函数
		>> 析构函数如何工作
			% 先执行函数体,再销毁成员,成员按初始化顺序的逆序销毁(初始化顺序为成员在类中的顺序)
			% 析构部分是隐式的
			% 注意：隐式销毁一个内置指针不会delete它所指向的对象
			% 容器的析构函数会销毁容器中的元素
		>> 合成析构函数
			% 当类中未指定析构函数时,编译器会为它定义一个合成析构函数
			% 合成析构函数的函数体为空
	
	$ 三/五法则
		>> 需要析构函数的类也需要拷贝构造函数和拷贝赋值操作运算符
			% 因为默认的合成拷贝构造函数只是简单的赋值操作,这对某些new的对象可能会被类的析构函数释放,导致资源无效
		>> 需要拷贝操作的类型也需要赋值操作,反之也是一样
		
	$ 使用=default
		>> 当使用=default时默认由编译器生成合成拷贝控制成员
		>> 如果在类中用default修饰成员的声明时,合成的函数将隐式声明为内联的
	
	$ 阻止拷贝
		>> 如iostream类,为避免多个对象写入或读取相同的IO缓冲,因此需要阻止拷贝
		>> why:
			% 如果不定义拷贝控制成员函数,则类还是由编译器生成合成的版本
		>> 删除的函数
			% 虽然声明了,但是不能以任何的方式使用
			% 形如：class(const &classs) = delete; //在参数列表后加上=delete
			% =delete 必须出现在函数第一次声明的时候
			% 任何函数都可以指定 =delete
			% 析构函数不能指定 =delete
			% 当类中存在不可能拷贝、赋值或者销毁成员时,则类的合成拷贝控制成员就被定义为删除
		>> private拷贝控制
			% c++11之前,当拷贝构造函数和拷贝赋值运算符声明为private时,是用于阻止拷贝的
			% 在声明为private并且不定义拷贝构造函数和拷贝赋值运算符时,友元和成员函数也将无法进行拷贝
	
--------------------
13.2、拷贝控制和资源管理	
	>> 通过定义拷贝操作,使类的行为看起来像一个值或者指针
		% 类像值,则说明拷贝类时,类与类之间是独立的
		% 类像指针,则说明类是共享状态,拷贝类时共用相同的底层数据
	
	$ 行为像值的类
		>> 要求每个对象都有自己的一份拷贝
		>> 赋值运算符
			% 如果将一个对象赋予它自身,赋值运算符必须能正常工作
			% 大多数赋值运算符组合了析构函数和构造函数的工作(释放原来的对象,构造新的对象)
			% 编写正确的赋值运算符的一个模式是：先构造临时变量拷贝右侧运算对象,再释放左侧运算对象
	
	$ 行为像指针的类
		>> 实现行为像指针的类有两种方式：shared_ptr、和引用计数
		>> 引用计数
			% 计数器不能作为类的成员
	
--------------------
13.3、交换操作
	>> 用于交换两个元素,一般管理资源的类通常都会存在swap成员函数
	>> 注意：标准库中同样存在swap函数,因此在调用时,可能调用的是标准库的swap
		% 建议在自定义的swap函数中增加语句：using std:swap;
		% 在自定义的swap函数中,如果增加了上述语句,则会根据参数进行匹配合适的swap函数
	
--------------------
13.4、示例
	>> 自定义的拷贝赋值运算符一定要考虑自赋值的情况
	>> 自定义的swap函数是否能够提高性能(避免重新申请内存),否则没必要重新定义
	
--------------------
13.5、动态内存管理
	>> 对于string类,新的标准库提供了两种机制,避免string的拷贝
		% 移动构造函数,只移动不拷贝
		% move标准库函数：通常不为move提供using声明,使用std::move
			std::move(string s);返回string的移动构造对象,string管理的内存不会被拷贝,只会被新元素接管

--------------------
13.6、对象移动
	>> 新标准支持,移动会相对于拷贝提示性能,并且某些类并不支持拷贝,如unique_ptr和IO类
	
	$ 右值引用
		>> 右值引用就是必须绑定到右值的引用,使用&&来获得右值引用
			% 只能绑定到一个将要销毁的对象
			% 形如：int &&rr = i * 42;
		>> 左值长久,而右值短暂
			% 左值有持久的状态,而右值要么是字面常量,要么是在表达式求值过程中的临时对象
		>> 变量是左值
			% 右值引用不能绑定到一个右值引用类型上
		>> 标准库move函数
			% move函数用于将一个左值转换成右值引用类型
			% 形如：int &&rr3 = std::move(rr1);
			% 调用move后,意味着只能对rr1进行赋值或者销毁,而不能使用它
	
	$ 移动构造函数和移动赋值函数
		>> 移动构造函数
			% 第一个参数为该类类型的右值引用,其它参数都必须有默认实参
			% 移动完成后,源对象不能再指定被移动的资源,意味着源对象调用析构函数是无害的
			% 移动操作一般不应抛出异常,使用noexcept(新标准)在函数的列表后指定,且声明和定义都需要指定
			% 不抛出异常的原因是因为：避免抛出异常时会达不到某些标准库容器在异常后要求的行为
		>> 移动赋值运算符
			% 需要检测自赋值的情况(一般通过检测传递的右值引用地址是否与this一致)
		>> 合成的移动操作
			% 当类中不存在任何自定义的拷贝控制成员,且每个非static的类成员都可以移动时,编译器才会合成移动操作
			% 内置类型或者定义了移动操作的类都是可移动的
			% 当定义了移动构造函数或移动赋值操作,则合成拷贝构造函数和拷贝赋值运算符会被定义为删除的
		>> 当同时定义了拷贝和移动操作,则进行合适的匹配,左值匹配拷贝操作,右值匹配移动操作
		>> 当只定义了拷贝构造函数时,传递的是右值引用,则同样可以使用拷贝构造函数
			% 原因：int &&rr2可以转化成 const int &r1;
		>> 移动迭代器(新标准下的标准库支持)
			% 与一般迭代器解引用返回左值不同,移动迭代器解引用返回右值引用
			% 使用标准库函数：make_move_iterator接受一个普通迭代器,返回一个移动迭代器
	
	$ 右值引用和成员函数
		>> 通常可以给一个函数定义两个版本：
			% func(const T&); //传递一个const的左值引用,进行拷贝
			% func(T&&);	  //传递一个右值引用,进行移动
	
	
==========================================================================================================	
第14章：重载运算与类型转换
--------------------
14.1、基本概念
	$ 重载的运算符
		>> 具有特殊的名字,由关键字operator和其后要定义的运算符号组成,包含返回类型,参数列表和函数体
			% 参数和该运算符作用的运算对象数量一样多
			% 成员运算符函数左侧运算对象绑定this指针上
			% 除了重载后的operator之外,重载的运算符不能含有默认实参
			% 运算符作用与内置类型时,无法进行重载,只能作用类类型才能重载
			% 一般情况下,不重载逗号,取地址,逻辑与和逻辑或运算符--重载后的原求值顺序无法保留
		>> 运算符重载为成员函数
			% 左侧对象必须是运算符所属类的一个对象
			% 改变对象状态通常应该重载为成员函数
			% 赋值、下标、调用、成员访问箭头(->)运算符必须是成员
			
--------------------
14.2、输入和输出运算符
	$ 重载输出运算符<<
		>> 重载的输出运算符有以下几点：
			% 第一个形参一般为非常量的ostream(会改变状态并且不允许赋值),第二个形参一般为常量的引用
			% 返回值为ostream形参
			% 输出运算符不应该打印换行符
			% 输入输出运算符必须是非成员函数
			% IO运算符一般会读写类的非公有数据成员,因此IO运算符一般被定义为类的友元
			
	$ 重载输入运算符>>
		>> 重载的输入运算符有以下几点：
			% 第一个形参为将要读取流的引用,第二个形参为读入到的非常量对象的引用,返回给定流的引用
			% 输入运算符需要检测是否失败

--------------------
14.3、算术和关系运算符
	>> 通常定义为非成员函数,不改变操作对象状态,因此形参为常量的引用
	
	$ 相等运算符
		>> 类的设计中如果需要判断两个对象是否一致,显然定义成operator==比较合适,避免重新使用新的函数名字
		>> 定义了operator==时也应该定义operator!=操作
		
	$ 关系运算符
		>> 只有存在一种逻辑可靠的<定义,才应该考虑定义<运算符
		>> 若类中包含==,则只有在<定义和==产生的结果一致时才定义<运算符

--------------------
14.4、赋值运算符
	>> 除了构造的拷贝赋值和移动赋值,还可以定义其他的赋值操作,如vector的花括号列表赋值操作
	>> 赋值运算符必须是成员函数
	>> 赋值运算符应该返回左侧运算对象的引用

--------------------
14.5、下标运算符
	>> 形如：operator[],必须是成员函数
	>> 返回值一般为所访问元素的引用
	>> 通常定义两个版本,一个返回普通引用,一个是类的常量成员(参数列表后const修饰)并返回常量引用

--------------------
14.6、递增和递减运算符
	>> 递增和递减的运算符重载后应该支持前置和后置两个版本
		% 为了区分,后置版本接受一个额外的int类型的形参(不使用)
		% 前置应该返回递增或者递减后的对象引用
		% 后置返回递增或者递减前的原对象的值

--------------------
14.7、成员访问运算符
	>> 重载的->必须返回类的指针或者自定义了箭头运算符的某个类的对象

--------------------
14.8、函数调用运算符
	>> 当类定义重载了函数运算符,则可以像调用函数一样调用这个类
		% 形如：abs为一个类,且重载了函数运算符,则可以直接调用 int i = abs(a);
	>> 若类定义了调用运算符,则这个类的对象称为函数对象
	
	$ lambda是函数对象
		>> lambda类似一个未命名的,只有一个函数运算符的类
		>> lambda的捕获的变量如果是值的方式,则要求lambda产生的类中包含该成员
		
	$ 标准库定义的函数对象
		>> 标准库定义了一组表示算法运算符、关系运算符和逻辑运算符的类
		>> 比较运算符不能用来比较指针类型,通常使用less进行比较
			% 形如：less<string *>()(ps1, ps2)

	$ 可调用对象与function
		>> 因为可能调用对象的类型不一致,但调用形式是相同的.
			% 如：int(int, int) //调用对象可以执行不一样的操作,但是调用形式都是一致的
		>> 为了调用合适的调用对象,引入了函数表
			% 函数表：用于存储指向这些可调用对象的“指针”
			% 函数表可以通过map实现
		>> 函数表中存储的是指针,而lambda表达式以及类重载的运算符都不属于指针,因此引入了function标准库类型
			% 新的标准库类型
			% 形如：function<int(int, int)> f1 = add;

--------------------
14.9、重载、类型转换与运算符
	$ 类型转换运算符
		>> 类的一种特殊成员函数,负责将一个类类型的值转换成其他类型
			% 形如：operator int() const; //表示将类类型转换成int
			% 类型转换运算符无返回值、形参和函数体,一般定义为const成员
			% 类很少提供类型转换运算符,因为上述描述的均是隐式的类型转换,会在很多时候导致误解
		>> 显式的类型转换运算符
			% 通过explicit修饰转换运算符,将转换运算强制成了显式的转换
			% 通过static_cast<int>进行显式的转换,形如 static_cast<int>(si) + 3; //类si强制转换成int
			% 当表达式被用作条件时,显式的类型转换也会隐式的执行
	
	$ 避免有二义性的类型转换
		>> 定义了多种向同一类型转换的方式
		>> 多个转换运算符的参数类型间都可以相互转换
	
	$ 函数匹配与重载运算符
		>> 重载后的运算符采用的是通用的函数匹配规则


==========================================================================================================	
第15章：面向对象程序设计
--------------------
15.1、OOP：概述
	>> OOP：面向对象程序设计的核心思想是数据抽象、继承和动态绑定
		% 数据抽象：类
		% 继承：定义相似的类型并对其相似关系建模
		% 动态绑定：在一定程度上忽略类型的区别,以统一的方式使用它们的对象
	$ 继承
		>> 基类
			% 通过继承联系在一起的类构成层次关系中的根部称为基类
			% 定义了在层次关系中所有类共同拥有的成员
		>> 派生类
			% 其他从基类直接或间接继承得到的类称为派生类
			% 派生类中定义了各自特有的成员
			% 形如：class f1: public f2 { public: int func1(int) override; }
			  表示f1继承了f2，其中override表示函数func1为虚函数
		>> 虚函数
			% 对于某些函数,基类希望其他的派生类各自定义适合自身的版本,此函数称为虚函数
			% 形如：virtual int func(int); //关键字virtual表示此函数为虚函数
			
	$ 动态绑定
		>> 在运行时根据实参的类型不同选择函数的版本,称为动态绑定或者运行时绑定
		
--------------------
15.2、定义基类和派生类
	$ 定义基类
		>> 基类通常应该定义一个虚析构函数
		>> 虚函数用来表示基类希望派生类自定义函数进行覆盖
			% 除了构造函数之外的非静态函数都可以是虚函数
			% virtual关键字只能出现在类的声明中,类外部函数定义不能使用
		>> 派生类的访问控制
			% 正常情况,只能访问基类的公有成员
			% 当基类使用关键字protected则表示派生类可以访问该成员
	
	$ 定义派生类
		>> 派生类需要重新在类中声明需要覆盖的那些函数
		>> 当在派生列表中使用public时,在任何需要基类的引用或者指针都能使用派生类的对象
		>> 只继承一个类的形式成为“单继承”
		>> 如果不覆盖虚函数,派生类则会直接继承基类的虚函数版本
		>> 如果覆盖虚函数,则可以在新标准下增加override关键字
			% override关键在形参列表后或者const关键字之后
		>> 基类的指针或者引用可以绑定到派生类的基类部分上,实现派生类到基类的类型转换
		>> 对于派生类中的基类成员,必须使用基类的构造函数进行初始化
		>> 若基类中定义了一个静态成员,则在整个继承中,只存在该成员的唯一定义
		>> 派生类的声明只包含类名,不包含派生列表
		>> 如果不希望其他类继承它,则在c++11的标准下支持如下格式
			% 形如：class last final {.....};类名后加final表示类last不支持继承
	
	$ 类型转换和继承
		>> 指针、引用、智能指针都支持基类绑定到其派生类的对象上
		>> 基类向派生类的转换是不被允许的,除非使用static_cast进行转换
		>> 当使用一个派生类为一个基类对象初始化或者赋值时,只有派生类中的基类部分会被执行操作
		
--------------------
15.3、虚函数
	>> 虚函数无论是否使用都必须被定义
	>> 多态性：OOP的核心思想
		% 具有继承关系的多个类型称为多态类型
	>> 派生类的函数如果覆盖了继承而来的虚函数,则它的形参、返回类型必须与继承的基类函数一致
		% 例外：返回类型是类的本身的指针或者引用
	>> 关键字overrride表示派生类中的函数是覆盖继承而来的虚函数
	>> 虚函数支持默认实参
		% 默认实参值取决于本次调用的静态类型决定,即使后续运行时绑定到了别的类型也是如此
	>> 使用作用域运算符可以实现避免虚函数的动态绑定
		% 形如：int a = basep->BASE::func(12); //basep指向的静态类型为BASE,动态类型是什么
		  调用的都是BASE类型的函数
    
--------------------
15.4、抽象基类
	>> 纯虚函数
		% 表明此虚函数无任何意义
		% 形如：int func(int) const = 0; // 表示func为纯虚函数
		% =0 只能出现在类的内部,而如果想要定义纯虚函数,则只能在类外
	>> 抽象基类
		% 含有纯虚函数(或者未经覆盖直接继承)的类称为抽象基类
		% 抽象基类不能直接创建一个抽象基类的对象
		
--------------------
15.5、访问控制与继承
	>> 受保护的成员
		% 使用关键字protected表示该成员只允许派生类的成员或者派生类的友元访问
		% 派生类的成员或者派生类的友元只能通过派生类对象来访问基类受保护的成员
	>> 访问权限
		% 派生访问说明符的目的是控制派生类用户对于基类成员的访问权限,不影响派生类成员的访问权限
		% 派生类的派生类同样受派生访问说明符的访问控制
	>> 友元与继承
		% 友元不能进行传递,也不能继承
		% 友元能够访问其类下的派生类的继承成员,但不能访问其派生类自定义的成员
	>> 修改某些成员的访问级别
		% 使用using声明可以修改派生类中继承成员的访问级别
		% 形如：class D::private B{ public: using B::size(); protected:using n; } 
		% 上述的方式表明：类D的用户可以访问size,派生类的成员和友元可以访问n
	>> 默认的继承保护级别
		% class关键字定义的派生类默认是私有继承的,struct则是公有继承的
		% clase和struct的唯一差别在于：默认成员的访问说明符以及默认的派生访问说明符
	>> 派生类到基类的转换
		% 只有当公有的继承时,用户代码才能使用派生类到基类的转换
		% 不管派生类D以什么方式继承B,其D的成员或者友元都可以执行派生类到基类的转换
		% 当D是以公有或者受保护的方式继承与B,则D的派生类才能执行D到B的转换,私有的继承则不能
		
--------------------
15.6、继承中的作用域		
	>> 当存在继承关系时,派生类的作用域嵌套在其基类的作用域之内
	>> 一个对象、引用或者指针,其静态类型决定了那些成员是可见的,即使与动态类型不一致的情况
	>> 派生类中重用定义直接基类或间接基类的名字时,内层作用域覆盖外层作用域
		% 可以通过作用域运算符使用被覆盖的成员

--------------------
15.7、构造函数和拷贝控制
	$ 虚析构函数
		>> 在基类中定义虚析构函数,以便释放对象时执行正确的析构函数
		>> 在基类中定义了虚析构函数,则不一定需要拷贝和赋值操作
		>> 在基类中定义了虚析构函数,则其和其派生类将会使得编译器不会为其合成移动操作
		
	$ 合成拷贝控制与继承
		>> 构造函数在派生类中会调用基类的构造函数初始化基类部分成员
			% 同样的,拷贝构造函数和析构函数也是如此
		>> 派生类中删除的函数与基类的关系
			% 基类的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的或者不可访问的,则派生类
			  对应的也是被删除的
			% 基类存在不可访问或者删除的析构函数,则派生类中的默认和拷贝函数将是被删除的
			% 基类中的析构函数是不可访问的或者删除的,则派生类的移动构造函数也将是删除的
		>> 移动操作与继承
			% 当派生类需要执行移动操作时,必须在其基类显示定义移动操作以及拷贝操作
	
	$ 派生类的拷贝控制成员
		>> 定派生类中定义了移动或者拷贝函数时,必须也要移动或者拷贝基类部分成员,赋值运算符也是如此
			% 与析构函数不同,析构函数只负责销毁派生类自己分配的资源
		>> 定义派生类的拷贝或移动构造函数
			% 若在派生类想拷贝或者移动基类部分,则要在构造函数的初始值列表中显示调用基类的拷贝或移动构造函数
		>> 派生类赋值运算符
			% 派生类的赋值运算符必须显式地为基类部分赋值
		>> 派生类的析构函数调用顺序与继承方向相反
		>> 如果构造函数或者析构函数调用了虚函数,则调用的是所属类型的虚函数
		
	$ 继承的构造函数
		>> 使用using声明表示派生类继承了基类的构造函数
			% 形如：using BASE::BASE(); //继承了类BASE的构造函数base
			% 继承了基类的构造函数后,其派生类的成员执行默认初始化
			% using作用在构造函数不会改变该构造函数的访问级别
		>> 构造函数继承
			% 派生类继承基类构造函数的explicit和constexpr属性
			% 派生类不会继承基类构造函数的默认实参,相反是得到多个基类的构造函数代替默认实参
			% 继承而来的构造函数不能别用户使用,只含有一个继承的构造函数时,编译器会合成一个默认构造函数
			% 默认、拷贝和移动构造函数不能被继承
		
--------------------
15.8、容器与继承
	>> 容器不允许保存于类型不符合的对象,当容器中保存的是基类类型时,添加的派生类对象将只保留基类部分
	>> 在容器中放置指针而非对象
		% 在容器存放具有继承关系的对象时,应选择指针或者只能指针类型

--------------------
15.9、示例
	>> 根据实际场景得到应该包含的操作
	>> 根据场景设计合适的基类和派生类的继承关系
	>> 定义接口类隐藏继承体系

==========================================================================================================	
第16章：模板与泛型编程
	>> 模板是泛型编程的基础,模板是一个创建类或函数的蓝图或者说公式
--------------------
16.1、定义模板
	$ 函数模板
		>> 函数模板就是一个公式,用来生成针对特定类型的函数版本
		>> 模板定义
			% template关键字开头,后跟一个【模板参数列表】,包含一个或者多个【模板参数】
			% 模板定义中,模板参数列表不能为空
			% 形如：template <typename T> int func(T &v1, T &v2) {......};
		>> 实例化函数模板
			% 编译器用函数实参来推断特定模板实参版本的函数的过程称为模板的实例
		>> 模板类型参数
			% 模板类型参数T可以用作返回值、函数参数类型、变量声明或类型转换
			% 类型参数T前必须使用关键字：typename或者class
		>> 非类型模板参数
			% 一个特定的类型名,而没有使用关键字typename或class
			% 整型的非类型参数的实参必须是常量表达式,指针或者引用的实参则必须是具有静态的生存周期
		>> 模板函数支持inline或者constexpr
			% 形如：template<typename T> inline T func(T&);
		>> 模板编译
			% 编译器只有在实例化模板(使用模板)时才生成代码

	$ 类模板
		>> 格式
			% 关键字template后接模板参数列表
			% 形如：template <typename T> class C1 {........};
		>> 实例化类模板
			% 使用类模板时,必须提供显式的模板实参列表
			% 形如：C1<int> c;
			% 注意：typename用在类型别名时,必须使用在类模板的类的定义里
				    格式：typedef typename int int_32;
		>> 类模板的成员函数
			% 成员函数可以定义在类内或者类外,类内默认为inline函数,类外则需要关键字template加模板参数列表
			% 形如：template <typename T> void C1<T>::member(int, int){......}；
			% 默认情况,类模板的成员函数只有在使用时才进行实例化
		>> 在类模板自己的作用域内使用类模板时,不需要提供模板实参
		>> 类模板和友元
			% 类与友元各自是否是模板是无关的
			% 当类模板内的友元非模板时,友元有权访问所有类模板的实例
			% 使用类模板之前,必须先声明,声明包括模板参数列表
			% 形如：类C的友元：template <typename T> friend class P; //表示P的所有实例都是每个类C的友元
			% 形如：类C的友元：friend class P1<T>; //表示C声明了共同通过T实例化P1为友元
			% 新标准中,模板类型参数可以声明为友元,形如：template <typename TYPE> class C{friend TYPE;};
		>> 模板类型别名
			% 实例化的类模板才能进行类型别名,形如 typedef C<string> strC;
			% 新标准下,允许为类模板定义一个类型别名,形如：template<typename T> useing twin = pair<T, T>;
		>> 类模板的静态成员
			% 对于类模板含有的静态成员,每个类实例化后都拥有其静态成员示例,相同类型的类模板共享静态成员
			
	$ 模板参数
		>> 作用域
			% 声明之后,至模板声明或者定义结束之前
			% 在模板内不能重用模板参数名(作为其他用途的名字)
		>> 使用类的类型成员
			% 注意：在类中,使用作用域运算符(::)来访问只有静态成员和类型成员
			% 当使用模板类型参数的类型成员时,应使用typename显式的说明
			% 形如：typename T::value_type func(T&);
		>> 默认模板实参(新标准支持为函数模板和类模板提供默认实参)
			% 使用：template <typename T, typename F = less<T>> func(T &v1, T &v2, F f=F()){.....};
		>> 当类使用<>则表示此类为类模板实例化而来,当使用空的<>时表示使用默认模板实参
		
	$ 成员模板
		% 普通类和类模板可以包含本身是模板的成员函数,这种成员称为成员模板,成员模板不能是虚函数
		
		>> 普通类的成员模板
			% 与普通的成员函数模板的声明和定义一致
		>> 类模板的成员模板
			% 在类模板外定义成员模板需要同时为类模板和成员模板提供模板参数列表
			% 形如：template<typename T> template<typename it> C<T>::C(it a)
		
	$ 控制实例化
		>> 显示实例化(新标准中支持)
			% what：为了解决多个独立的文件使用了相同模板时而生成多份相同的实例
			% how：
				声明：extern template class C<string>; //编译器遇到此语句时不会再实例化,但必须在别处有定义
				定义：template class C<string>; //编译遇到定义会实例化并生成代码
			% note：
				extern声明必须出现在任何使用此实例化的代码之前,否则还是会进行实例化
				类模板的实例化定义会实例该模板下所有的成员,而不是如普通的只有在使用时才进行实例化
				
	$ 效率与灵活性
		>>share_ptr与unique_ptr删除器
			% share_ptr的删除器可以在创建或者reset指针时传递给它一个可调用对象
			% unique_ptr对象类型的一部分,必须在定义时显式的提供
			
--------------------
16.2、模板实参推断
	% 从调用的函数实参来推断模板实参的过程称为模板实参推断
	
	$ 类型转换与模板类型实参
		>> 类型转换
			% 非const到const的转换是支持的
			% 数组或函数到对应类型的转换
			% 算术转换、派生类向基类的转换、用户定义的转换等
			% 注意：形参是一个引用时,数组不会转换成指针
		>> 使用相同的模板参数类型的函数形参
			% 当一个模板类型参数用作多个函数形参的类型时,传递的实参类型必须一致
			% 如果要想支持不同的实参类型,则需要定义不同的模板类型参数作为形参
			% 当函数参数类型不是模板参数,则对实参进行正常的实参到形参的类型转换
	
	$ 函数模板显示实参
		>> 指定显式模板实参
			% 显式模板：模板参数不定义无法由编译推断出来,必须由调用者提供一个显式模板实参
			% 格式：template <typename T1, typename T2, typename T3> T1 sum(T2,T3);
					指定：sum<long long>(int, long);
			% 显式模板实参按由左至右的顺序与对应的模板参数匹配
		>> 正常类型转换应用于显式指定的实参
			% 当指定了显式的实参后,对于调用可以进行正常类型的转换
	
	$ 尾置返回类型与类型转换
		>> 尾置返回类型用于在参数列表之后声明返回类型
			% 形如：template <typename It> auto fcn(It beg, It end) ->decltype(*beg){return *beg;};
			  decltype返回于beg表示的元素的类型的引用
		>> 使用remove_reference来获得元素类型
			% 形如：remove_reference<decltype(*beg)>::type //返回元素类型本身

	$ 函数指针和实参推断
		>> 当使用函数模板初始化一个函数指针或者为函数指针赋值,编译器使用指针的类型推断模板实参
		>> 只用当确定模板实参的唯一类型时实例化才能成功
	
	$ 模板实参推断和引用
		>> 模板参数为普通(左值)引用时,推断的模板类型为左值或者返回引用类型的表达式
		>> 模板参数为const引用时,推断的模板类型可以为左值或者右值(常量也支持)
		>> 当模板参数为右值引用时,推断的模板类型是右值(常量或表达式)
			% 形如：template <typename T> void f(T&&); f(42)的调用是合法的
		>> 当模板参数为右值引用时,调用是传递的实参为左值,则模板类型推断的为左值的引用
			% 形如：f(i); //i为int,则模板推断T为：int&
			% 对引用的引用可以折叠：如：int& && 折叠为int&;对于：int&& &&折叠为int&&
		
	$ 理解std::move
		>> move的一个作用是获得一个绑定到左值上的右值引用
			% 采用了：static_cast显示的将左值转换成右值引用
	
	$ 转发
		>> 某些函数需要将其一个或多个实参连同类型不变的[转发]给其他函数
		>> 如果一个函数的参数是指向模板类型参数的右值引用时,其对于实参的const属性和左值右值属性得到保持
		>> std::forward
			% 返回显示实参类型的右值引用
			% 形如：forward<T>; //返回T&&的右值引用
			% forward会保持实参类型的左值或者右值属性
			
--------------------
16.3、重载与模板
	% 函数模板可以被另一个函数模板或普通非模板函数重载,要求具有不同数量或者类型的参数
	% 特例化版本
		>> 当多个重载模板对一个调用提供同样好的匹配时,应选择最特例化的版本
		>> 特例化版本是形如：func(T*);而非func(const T&)
	% 模板与非模板重载
		>> 当模板函数与非模板函数提供同样好的匹配,则选择非模板函数
	% 重载模板和类型转换
		>> 数组到指针的转换,对于函数匹配而言,这种转换被认为是精确匹配
			
--------------------
16.4、可变参数模板
	% 概念
		>> 可变参数模板：一个接受可变数目参数的模板函数或模板类
		>> 参数包：可变数目的参数称为参数包
			% 模板参数包：零个或多个模板参数
			% 函数参数包：零个或者多个函数参数
			% 用一个省略号来指出一个模板参数或函数参数表示一个包
			% 形如下面格式表示：Args为模板参数包,rest为函数参数包
			template <typename T, typename... Args> void f(const T&, const Args& ... rest);
		>> sizeof...()用于获取参数包的个数
    
	$ 编写可变参数函数模板
		>> 可变参数函数通常是递归的
			% 非可变参数版本的声明必须在作用域内,否则会无限递归
			% 非可变参数版本较可变参数版本更加特例化
		
	$ 包扩展
		>> 概念
			% 扩展一个包就是将它分解为构成的元素,对每个元素应用模式,获得扩展后的列表
		>> 实现
			% 在模式的右边放一个省略号
			% 形如：template <typename &T, typename... Args> void func(const T &t, const Args&... rest);
		
	$ 转发参数包(新标准下支持)
		>> 使用可变参数模板与forward机制来实现实参不变地传递给其他函数
			% forward实现右值的转换,并且保持实参类型的属性

--------------------
16.5、模板特例化
	% 模板特例化就是模板的一个独立定义,在其中一个或多个模板参数被指定为特点的类型
	% 定义函数模板特例化
		>> 当特例化一个函数模板时,必须为原模板参数提供实参,形如
			% template <> int func(const char* const &p1, const char* const &p2);
		>> 当特例化一个模板时,原模板声明必须在作用域中
	% 类模板特例化
		>> 类模板特例化支持部分特例化,即不必为所有的模板参数提供实参
			% 形如：template <typename T> strcut S<T&>{...}; //部分特例化了一个左值引用
		>> 支持特例化成员函数而不是特例化整个模板

==========================================================================================================	
第17章：标准库特殊设施
--------------------
17.1、tuple类型
	% 类似pair,不同的是tuple类型可以有任意数量的成员
	% 作用：用于将数据组合成一个对象,而不以数据结构的方式
	
	$ 定义和初始化tuple
		>> 定义tuple
			% 需要指定每个成员的类型,形如：tuple<int, int, int> threeD; //未进行初始化,则进行值初始化为0
			% auto item = make_tuple<"1234", 1, 1.00>根据初始值类型来推断tuple的类型
			% 构造函数为explicit
		>> 访问tuple成员
			% 使用标准库函数模板：get获取tuple的成员
			% 形如：auto first = get<0>(item); //显示模板实参获取item的第一个成员,尖括号的值必须为常量表达式
			% tuple_size为一个类模板,接受一个tuple类型的模板实参,获得tuple类型中的成员个数
				形如：tuple_size<tuple>::value; //获取tuple类型的成员个数,其value为public static成员
			% tuple_elemet为类模板,接受索引和tuple类型的模板实参,获得指定成员的类型
				形如：tuple_elemet<0, tuple>::type; //其中type为public成员
		>> 关系和相等运算符
			% tuple的成员数量一致才可以进行比较,且每个成员都应该支持关系或者相等运算符
	
	$ 使用tuple返回多个值
		% 常用于函数返回多个值
			
--------------------
17.2、bitset类型
	% 用于位运算
	
	$ 定义和初始化bitset	
		>> bitset为一个类模板
			% 定义形如：bitset<32> bitvec(1U); //32位,低位为1,其他位为0
			% 编号从0~31,其中0开始的二进制位为低位,编号到31结束的为高位
			% 构造函数为constexpr
		>> 整型值初始化bitset,则整型值被转换为unsigned long long
			% 位数大于unsigned long long的二进制数,则高位置0
			% 位数小于unsigned long long的二进制数,则丢弃超出的高位
		>> string或者字符数组指针初始化bitset,则字符直接表示位模式
		
	$ bitset操作
		>> 改变bitset状态的成员函数
			% 都是重载的
			% 不接受参数的版本是对整个bitset的集合执行给定的操作,接受一个位置参数则对指定位执行操作
		>> 提取bitset的值
			% to_ulong和to_ullong都返回一个值,返回的是与bitset相同的位模式
			% 只有当bitset的位数小于等于上述两个类型大小时才能使用,否则会抛出异常

--------------------
17.3、正则表达式
	% c++的正则表达式库(RE库),为新标准的一部分,定义在头文件regex
	
	$ 使用正则表达式库
		>> 正则表达式规则
			% [^] 方括号中^表示非
			% [:alpha:]表示字母字符,[:space:]表示空格字符
			% [[:alpha:]]表示大小写字母,[[:space:]]表示空白字符
			% [[:alnum:]]表示字母和数字
			% ([[:alnum:]]+)表示一个或多个字符的序列
		>> 正则表达式函数
			% regex_search用于查找匹配正则表达式的子串,查找到匹配的即停止返回true
			% regex r(pattern); //构造一个用于查找模式的regex
			% regex r(pattern, f); //f表示指定的标志,如：regex::icase
			% regex::icase标志表示不区分大小写
			% regex_error e; //当编写的正则表达式存在错误时,会抛出regex_error的异常
			  e.code() //返回某个错误类型对应的错误码  e.what() //用来描述发生了什么错误
		>> 正则表达式的缺点
			% 在运行时编译,且是一个非常慢的操作,应该尽量避免regex的创建
		>> 在regex_search(pattern, match, regex);
			% match的类型应该与pattern的类型保持一致,如：pattern为char *, 则match为：cmatch
	
	$ 匹配与regex迭代器类型
		>> sregex_iterator来获得所有匹配
			% sregex_iterator的构造函数对给定string和regex调用regex_search得到符合的smatch对象
		>> 使用匹配结果类
			% 匹配结果类为smatch,cmatch,wsmatch,wcmatch
			% 匹配结果类支持前缀和后缀部分
				格式：smatch m; m.prefix()表示前缀部分,其得到的是类ssub_match
					  smatch m; m.suffix()表示后缀部分,其得到的是类ssub_match
			% 对于ssub_match有两个成员：length()表示大小,str()表示string
	
	$ 使用子表达式
		>> 子表达式
			% 一个子表达式是模式的一部分,本身也具有意义.正则表达式通常用括号表示子表达式
				形如：([[:alnum:]]+)\\.(cpp|cxx|cc),包括了两个括号括起来的子表达式
			% 匹配类结果smatch支持获取每个子表达式
				形如：smatch s;s.str(0)--获取整个匹配字符串,s.str(1)表示第一个子表达式的结构,以此类推
			% 子表达式的类为ssub_match sub;
				% sub.matched(); //表示第一个子表达式是否匹配,true表示匹配
				% sub.length();  //表示大小
				% sub.str();     //表示string
				
	$ 使用regex_replace		
		% regex_replace用于查找输入序列并替换一个正则表达式
		% 形如：regex_replace(s,r,fmt); //其中的s为输入的字符串,r为正则表达式,fmt为输出的格式
		% 匹配和格式化标志的类型为match_flag_type,其定义在命名空间std::regex_constants
		
--------------------
17.4、随机数
	% rand函数会产生某一范围内的均匀分布的随机整数
	% c++的头文件：random定义了一组类来解决rand的问题(随机数引擎类、随机数分布类)
	
	$ 随机数引擎和分布
		>> 随机数引擎
			% 随机数引擎为一个函数对象类,它定义了一个调用运算符：operator(),不接受参数
				形如：default_random_engine e; e(); //生成一个随机无符号数,范围为系统定义
					  
					  e.min();e.max(); //输出系统定义的随机数范围
					  default_random_engine e(1111) 和 e.seed(1111); //两种方式都是将1111作为随机数的种子
			% 随机数引擎的输出一般不能直接使用
				原因：生成的随机数一般与我们要求的范围不一致,需要进行转换
		>> 分布类型和引擎
			% 分布类型可以得到一个指定范围内的数,再加上引擎则可以得到一个范围的随机数
				形如：uniform_int_distribution<unsigned> u(0,9); //作为seed
					  default_random_engine e;
					  u(e); //生成指定范围的随机数
			% 分布类型为一个函数对象类,定义了一个调用运算符,接受随机数引擎为参数
				原理：利用随机数引擎来生成随机数,并将其映射到指定的范围内
			% 随机数发生器：分布对象+随机数引擎对象
			% 对于给定的随机数发生器,每次运行程序都会返回相同的数值序列
				解决办法：将分布对象和引擎对象定义为static
				
	$ 其他随机数分布
		>> 随机浮点数生成
			% uniform_real_distribution类型的对象处理随机整数到随机浮点数的映射
				uniform_real_distribution<double> u(0,1); //0到1的均匀分布
				u(e); //生成0~1的随机浮点数
		>> 分布类型
			% 分布类型为模板类型,存在着一个默认的模板实参,表示分布生成的随机数的类型
			% 生成浮点数的默认模板double、生成整形值的为int
		>> 不均匀分布
			% 分布类：normal_distribution<> n(4,1.5); //生成均值4、标准差1.5的正态分布的随机数
			
		>> bernoulli_distributoion类
			% 非模板类,是一个普通类
			% 返回bool值,返回true的概率默认为0.5
			% 构造函数接受一个参数,表示返回true的概率
	
--------------------
17.5、IO库再探
	$ 格式化输入与输出
		>> 格式状态
			% 用于控制IO如何格式化的细节：数值的输出形式、补白的数量和位置等等
		>> 操纵符
			% 一个函数或者一个对象
			% 返回所处理的流对象
			% endl：操纵符,用于输出一个换行,并且刷新缓冲区
			% 操纵符对格式状态的改变是持久的
			% boolalpha操纵符用于修改布尔值的方式,noboolalpha用于恢复
				形如：cout << boolalpha << true << "" << false; // 输出true false
			% hex、oct、dec将输出的整形值改为16、8、10进制
			% showbase用于显示输出的进制,noshowbase用于恢复
			% 流的percision成员用于返回当前精度或者接受一个新的精度返回旧精度
			% setpercision操纵符用于控制流的精度
			% showpoint强制输出小数点,noshowpoint则用于恢复
			% 默认情况：输出运算符会忽略空白符
				noskipws操纵符控制输入运算符读取空白符,skipws用于恢复
	
	$ 未格式化的输入/输出操作
		% 允许将流当做一个无解释字节序列进行处理
		>> 单字节操作
			% cin的操作get成员和cout的put成员不会跳过空白符
		>> 将字节放回输入流
			% cin.peek()：返回输入流的下一个字符的副本,但不会删除,返回的值仍存在流中
			% cin.unget()：使得输入流向后移动
			% cin.putback()：退回从流中读到的最后一个值
		>> 从输入操作返回的int值
			% cin.peek()和cin.get()都会返回一个int类型
	
	$ 流随机访问
		% iostream不支持随机访问的操作,只有fstream、sstream支持
		>> seek和tell函数
			% seek支持两个版本的：移动绝对位置和给定位置的偏移量
			% tellp和tellg获取流的当前位置
		>> 文件模式
			% fstream::ate表示定位到文件的末尾
			% fstream::beg表示文件开始位置
			% fstream::end表示文件末尾位置
		
==========================================================================================================	
第18章：用于大型程序的工具
--------------------
18.1、异常处理
	$ 抛出异常
		>> throw
			% throw抛出异常后,后面的语句将不再执行,程序的控制权转移到与之匹配的catch模块
			% 通常作为条件语句的一部分或者某个函数的最后一条语句
		>> 栈展开
			% 栈展开：寻找与异常匹配的catch子句的过程称为栈展开(按照嵌套函数的调用链进行查找)
			% catch执行完成后,找到与try关联的最后一个catch子句之后继续执行
			% 如果查找不到匹配的catch语句,则程序将退出
			% 栈展开的过程中,如果退出了某个快,则块中创建的对象会被正确的销毁(由编译器负责)
			% 所有标准库类型都能确保它的析构函数不会引发异常
		>> 异常对象
			% 异常对象位于由编译器管理的空间中
			% 由编译器使用异常抛出表达式来异常对象进行拷贝初始化
			% 异常对象类必须存在可访问的：析构函数、拷贝或者移动构造函数
			% 抛出异常表达式的静态编译类型决定了异常对象的类型
			
	$ 捕获异常
		>> catch子句
			% 声明的异常类型必须是完全类型,可以是左值引用,但不能是右值引用
			% catch的参数是基类：
				基类非引用时,可以使用派生类进行初始化,但会被切割
				基类为引用时,则绑定到异常对象上
			% catch的异常声明为静态类型,如catch的参数类型为基类,则不能使用派生类特有的成员
		>> 查找匹配的处理代码
			% catch语句按照出现的顺序逐一匹配
			% 只存在三种类型转换的匹配方式,其他方式的转换是不被允许的
				非常量到常量的转换
				派生类到基类的转换
				数组到指向数组的指针,函数指向函数的指针间的转换
		>> 重新抛出
			% 在catch可以继续抛出之前捕获的异常
				格式：throw; //在catch中将当前的异常对象沿着调用链向上传递
		>> 捕获所有异常的处理代码
			% 捕获所有异常的格式：catch(...)
			
	$ 函数try语句块和构造函数
		% 构造函数体内的catch语句无法处理构造函数初始值列表抛出的异常
		% 函数try语句块(函数测试块)--既能够处理初始值列表抛出的异常,也能处理构造函数体内的抛出的异常
			形如：Blob::Blob(int i) try : data(i){}catch(error &e) {....};
			
	$ noexcept异常说明
		% c++11标准支持：noexcept说明指定某个函数不会抛出异常
		% 格式：void func(int i) noexcept;
		% noexcept说明出现在尾置返回类型之前,成员函数出现在const和引用限定符之后,final、overrride之前
		% 编译器不检查那些声明了noexcept的,但是抛出异常的函数,编译依然能通过
		% 旧的版本：void func(int i) throw(); //等价与noexcept
		% noexcept接受一个可以转化成bool值的可选实参
			形如：void func(int) noexcept(true); //不会抛出异常,反正为false则可能会抛出异常
		% noexcept运算符：一元运算符,用于判定给定表达式是否会抛出异常,是则返回bool值false,否则为true
		>> 函数指针、虚函数与异常说明
			% 当函数指针做了不抛出异常的声明,则此函数指针只能指向不会抛出异常的函数
			% 当基类的虚函数做了不抛出异常的声明,则派生类的虚函数也必须声明为不会抛出异常
			% 不做不抛出异常的声明,则可以接受抛出异常或者不抛出异常声明的函数
	
	$ 异常类层次
		
	
	
	
	